// Generated by dts-bundle v0.7.3

declare module 'voximplant-websdk' {
    import { Client } from 'voximplant-websdk/Client';
    import Messaging from 'voximplant-websdk/Messaging';
    export { Messaging } from 'voximplant-websdk/Messaging';
    export { Events } from 'voximplant-websdk/Events';
    export { CallEvents } from 'voximplant-websdk/Call/CallEvents';
    export { Endpoint } from 'voximplant-websdk/Call/EndPoints/Endpoint';
    export { EndpointEvents } from 'voximplant-websdk/Call/EndPoints/EndpointEvents';
    export { OperatorACDStatuses, LoginTokens, VideoFlags, LogRecord, QueueTypes, ConnectionNode, AuthResultCode, MediaRendererKind, } from 'voximplant-websdk/Structures';
    export { LogCategory, LogLevel, ClientState } from 'voximplant-websdk/Logger';
    export * from 'voximplant-websdk/Hardware/index';
    export { MediaRenderDisablingReason } from 'voximplant-websdk/Media/MediaRenderDisablingReason';
    export { CallState } from 'voximplant-websdk/Call/AbstractCall';
    /**
        * Get a [Client] instance to use platform functions
        * @returns {Client}
        */
    export function getInstance(): Client;
    /**
        * Voximplant Web SDK lib version
        */
    export const version: string;
    /**
        * Get a [Messenger] instance to use Messaging functions
        * @returns {Messenger}
        *
        */
    export function getMessenger(): Messaging.Messenger;
}

declare module 'voximplant-websdk/Client' {
    import { Call } from 'voximplant-websdk/Call/Call';
    import { AudioOutputInfo, AudioSourceInfo, CallSettings, Config, LoginOptions, LogRecord, OperatorACDStatuses, VideoFlags, VideoSettings, VideoSourceInfo } from 'voximplant-websdk/Structures';
    import { Events } from 'voximplant-websdk/Events';
    import { VoxSignalingHandler } from 'voximplant-websdk/Signaling/VoxSignalingHandler';
    import { ClientState, LogCategory, LogLevel } from 'voximplant-websdk/Logger';
    import { EventListenerOption, EventTarget } from 'voximplant-websdk/EventTarget';
    import { EventHandlers } from 'voximplant-websdk/EventHandlers';
    import { MediaRenderer } from 'voximplant-websdk/Media/MediaRenderer';
    import { ViewerCall } from 'voximplant-websdk/Call/ViewerCall';
    import { SharingCall } from 'voximplant-websdk/Call/SharingCall';
    import { CodecDescription } from 'voximplant-websdk/PeerConnection/SDP/Interfaces';
    import { LoginState } from 'voximplant-websdk/LoginStateEnum';
    /**
        * The Client class is used to control platform functions. Cannot be instantiated directly (singleton), so use the [getInstance] method to get the class instance.
        */
    export class Client extends EventTarget<Events> implements VoxSignalingHandler {
            /**
                * @hidden
                */
            videoSupport: boolean;
            /**
                * @hidden
                */
            localVideoContainerId: string;
            /**
                * @hidden
                */
            remoteVideoContainerId: string;
            /**
                * @hidden
                */
            _defaultSinkId: string;
            /**
                * Enforce use turn serves for conference calls
                * If value is false turn servers possible, but not guarantee
                * @type {boolean}
                * @hidden
                */
            allowTurnForConferenceCalls: boolean;
            /**
                * @hidden
                */
            loginState: LoginState;
            /**
                * @type {Array}
                * @hidden
                */
            limitVCodecs: CodecDescription[];
            /**
                * @type {Array}
                * @hidden
                */
            limitACodecs: CodecDescription[];
            /**
                * @hidden
                */
            features: string[];
            /**
                * @hidden
                */
            constructor();
            /**
                * Returns the Voximplant Web SDK version.
                * @function
                * @hidden
                */
            get version(): string;
            /**
                * @hidden
                */
            static getInstance(): Client;
            /**
                * Plays a progress tone according to specified country in config.progressToneCountry.
                * @hidden
                */
            playProgressTone(check?: boolean): void;
            /**
                * Stops the progress tone.
                * @hidden
                */
            stopProgressTone(): void;
            /**
                * @hidden
                */
            onIncomingCall(id: any, callerid: any, displayName: any, headers: any, hasVideo: any): void;
            get alreadyInitialized(): boolean;
            /**
                * Initializes the SDK. The [Events.SDKReady] event is dispatched after successful SDK initialization. SDK cannot be used until it is initialized.
                * @param {VoxImplant.Config} [config] Client configuration options
                */
            init(config?: Config): Promise<EventHandlers.SDKReady | string>;
            /**
                * Creates a call.
                *
                * This method can throw the 1003 error if the client is not connected to the Voximplant Cloud or the 1004 error if the client is not authorized.
                * @name VoxImplant.Client.call
                * @param {(String|CallSettings)} num The number to call or [CallSettings](/docs/references/websdk/voximplant/callsettings). For SIP compatibility reasons it should be a non-empty string even if the number itself is not used by a Voximplant cloud scenario
                * @param {VideoFlags} useVideo Deprecated: Please, use [CallSettings](/docs/references/websdk/voximplant/callsettings) instead
                * @param {String} customData Deprecated: Please, use [CallSettings](/docs/references/websdk/voximplant/callsettings) instead
                * @param {Object} extraHeaders Deprecated: Please, use [CallSettings](/docs/references/websdk/voximplant/callsettings) instead
        
                * @returns {VoxImplant.Call}
                */
            call(num: string | CallSettings, useVideo?: boolean | VideoFlags, customData?: string, extraHeaders?: {
                    [id: string]: string;
            }): Call;
            /**
                * Creates a call to a dedicated conference without a proxy session. For details see the [video conferencing guide](/docs/guides/conferences/scenarios).
                *
                * This method can throw the 1003 error if the client is not connected to the Voximplant Cloud or the 1004 error if the client is not authorized.
                * @param {(String|CallSettings)} num The number to call or [CallSettings](/docs/references/websdk/voximplant/callsettings). For SIP compatibility reasons it should be a non-empty string even if the number itself is not used by a Voximplant cloud scenario
                * @param {Boolean} useVideo Deprecated: Please, use [CallSettings](/docs/references/websdk/voximplant/callsettings) instead
                * @param {String} customData Deprecated: Please, use [CallSettings](/docs/references/websdk/voximplant/callsettings) instead
                * @param {Object} extraHeaders Deprecated: Please, use [CallSettings](/docs/references/websdk/voximplant/callsettings) instead
                * @returns {Call}
                */
            callConference(num: string | CallSettings, useVideo?: boolean | VideoFlags, customData?: string, extraHeaders?: {
                    [id: string]: string;
            }): Call;
            /**
                * Calls the specified conference as a separate screen sharing participant.
                *
                * This method can throw the 1003 error if the client is not connected to the Voximplant Cloud or the 1004 error if the client is not authorized.
                * @param num The conference room ID. Use different room IDs for different conference rooms. You can launch different scenarios depending on this parameter by specifying this value as a [routing rule](/docs/getting-started/basic-concepts/routing) pattern.
                * @param sendAudio Whether to send audio stream (works only for Chrome, Edge)
                * @param extraHeaders
                */
            joinAsSharing(num: string | number, sendAudio?: boolean, extraHeaders?: {
                    [id: string]: string;
            }): SharingCall;
            /**
                * Calls the specified conference as viewer participant only for receiving audio/video.
                *
                * This method can throw the 1003 error if the client is not connected to the Voximplant Cloud or the 1004 error if the client is not authorized.
                * @param num The conference room number or ID
                * @param extraHeaders
                */
            joinAsViewer(num: string | number, extraHeaders?: {
                    [id: string]: string;
            }): ViewerCall;
            /**
                * Gets the current config.
                */
            config(): Config;
            /**
                * Connects to the Voximplant Cloud.
                */
            connect(): Promise<boolean>;
            /**
                * Disconnects from the Voximplant Cloud.
                */
            disconnect(): Promise<void>;
            /**
                * Sets the agent's status for SmartQueue and ACD v1 contact center.
                * @param {OperatorACDStatuses} Automatic call distributor status
                */
            setOperatorACDStatus(status: OperatorACDStatuses): Promise<OperatorACDStatuses>;
            /**
                * Sets the SmartQueue messaging status.
                * @param {OperatorACDStatuses} Automatic call distributor status
                */
            setOperatorSQMessagingStatus(status: OperatorACDStatuses): Promise<OperatorACDStatuses>;
            /**
                * Returns the current agent's status for SmartQueue and ACD v1 contact center.
                * @returns {Promise<OperatorACDStatuses>}
                */
            getOperatorACDStatus(): Promise<OperatorACDStatuses>;
            /**
                * Returns the current agent's status for SmartQueue messaging.
                * @returns {Promise<OperatorACDStatuses>}
                */
            getOperatorSQMessagingStatus(): Promise<OperatorACDStatuses>;
            /**
                * Logs in to an application. The method triggers the [Events.AuthResult] event.
                * @param {String} username Fully-qualified username that includes Voximplant user, application and account names. The format is: "username@appname.accname.voximplant.com"
                * @param {String} password The user's password
                * @param {VoxImplant.LoginOptions} [options]
                */
            login(username: string, password: string, options?: LoginOptions): Promise<EventHandlers.AuthResult>;
            /**
                * Logs in to an application via the 'code' auth method. The method triggers the [Events.AuthResult] event.
                *
                * Please, refer to the [documentation](/docs/guides/sdk/authorization-onetimekey).
                * @param {String} username Fully-qualified username that includes Voximplant user, application and account names. The format is: "username@appname.accname.voximplant.com"
                * @param {String} code
                * @param {VoxImplant.LoginOptions} [options]
                * @hidden
                */
            loginWithCode(username: string, code: string, options?: LoginOptions): Promise<EventHandlers.AuthResult>;
            /**
                * Logs in to an application via an accessToken. The method triggers the [Events.AuthResult] event.
                * @param {String} username Fully-qualified username that includes Voximplant user, application and account names. The format is: "username@appname.accname.voximplant.com"
                * @param {String} token
                * @param {VoxImplant.LoginOptions} [options]
                */
            loginWithToken(username: string, token: string, options?: LoginOptions): Promise<EventHandlers.AuthResult>;
            /**
                * Refreshes the expired access token.
                * @param {String} username Fully-qualified username that includes Voximplant user, application and account names. The format is: "username@appname.accname.voximplant.com".
                * @param {String} refreshToken
                * @param {String} deviceToken A unique token for the current device
                */
            tokenRefresh(username: string, refreshToken: string, deviceToken?: string): Promise<EventHandlers.AuthTokenResult>;
            /**
                * Requests a key for the 'onetimekey' auth method.
                * Server sends the key in the [Events.AuthResult] event with the code 302.
                *
                * Please read the article about the [authorization with one-time key](/docs/guides/sdk/onetimekey).
                * @param {String} username
                */
            requestOneTimeLoginKey(username: string): Promise<EventHandlers.AuthResult>;
            /**
                * Logs in to an application via the 'onetimekey' auth method.
                * Hash should be calculated with the key from the triggered [Events.AuthResult] event.
                *
                * Please read the article about the [authorization with one-time key](/docs/guides/sdk/onetimekey).
                * @param {String} username
                * @param {String} hash
                * @param {VoxImplant.LoginOptions} [options]
                */
            loginWithOneTimeKey(username: string, hash: string, options?: LoginOptions): Promise<EventHandlers.AuthResult>;
            /**
                * Checks if the client is connected to Voximplant Cloud.
                * @deprecated
                * See [[Client.getClientState]]
                */
            connected(): boolean;
            /**
                * Shows/hides the local video. *IMPORTANT*: Safari browser for iOS requires a user interface for playing video during a call. It should be interactive element like an HTML "button" with "onclick" handler that calls "play" method on the "video" HTML element.
                * @param {Boolean} [flag=true] Show/hide - true/false
                * @param {Boolean} mirror Deprecated
                * @param {Boolean} detachCamera Deprecated
                */
            showLocalVideo(flag?: boolean, mirror?: boolean, detachCamera?: boolean): Promise<MediaRenderer | void>;
            /**
                * Sets the local video position.
                * @param {Number} x Horizontal position (px)
                * @param {Number} y Vertical position (px)
                * @function
                * @hidden
                * @deprecated
                * @name VoxImplant.Client.setLocalVideoPosition
                */
            setLocalVideoPosition(x: number, y: number): void;
            /**
                * Sets the local video size.
                * @param {Number} width Width in pixels
                * @param {Number} height Height in pixels
                * @function
                * @hidden
                * @deprecated
                * @name VoxImplant.Client.setLocalVideoSize
                */
            setLocalVideoSize(width: number, height: number): void;
            /**
                * Sets the video settings globally. This settings is to be used for the next call.
                * @param {VoxImplant.VideoSettings|VoxImplant.FlashVideoSettings} settings Video settings
                * @param {Function} [successCallback] Success callback function has MediaStream object as its argument
                * @param {Function} [failedCallback] Failed callback function
                * @deprecated
                * @hidden
                */
            setVideoSettings(settings: VideoSettings, successCallback?: Function, failedCallback?: Function): void;
            /**
                * Sets the bandwidth limit for video calls. Currently supported by Chrome/Chromium. (WebRTC mode only). The limit is to be applied for the next call.
                * @param {Number} bandwidth Bandwidth limit in kilobits per second (kbps)
                */
            setVideoBandwidth(bandwidth: number): void;
            /**
                * Plays a ToneScript via WebAudio API.
                * @param {String} script Tonescript string
                * @param {Boolean} [loop=false] Loop playback if true
                */
            playToneScript(script: string, loop?: boolean): void;
            /**
                * Stops playing ToneScript via WebAudio API.
                */
            stopPlayback(): void;
            /**
                * Changes the current global sound volume.
                * @deprecated
                * @param {Number} level New sound volume value between 0 and 100
                * @function
                * @hidden
                */
            volume(level: number): number;
            /**
                * Gets a list of all currently available audio sources/microphones.
                * @deprecated
                * @hidden
                */
            audioSources(): AudioSourceInfo[];
            /**
                * Gets the list of all currently available video sources/cameras.
                * @deprecated
                * @hidden
                */
            videoSources(): VideoSourceInfo[];
            /**
                * Gets the list of all currently available audio playback devices
                * @deprecated
                * @hidden
                */
            audioOutputs(): AudioOutputInfo[];
            /**
                * Selects the specified audio source, use [audioSources] to get the list of available audio sources.
                * If SDK is init with micRequired: false, force attach microphone.
                * @param {String} id Id of the audio source
                * @param {Function} [successCallback] Called in WebRTC mode if audio source changed successfully
                * @param {Function} [failedCallback] Called in WebRTC mode if audio source could not changed successfully
                * @deprecated
                * @hidden
                */
            useAudioSource(id: string, successCallback?: Function, failedCallback?: Function): Promise<MediaStream>;
            /**
                * Selects the specified video source, use [videoSources] to get the list of available video sources.
                * @param {String} id Id of the video source
                * @param {Function} [successCallback] Called if video source changed successfully, has MediaStream object as its argument
                * @param {Function} [failedCallback] Called if the video source has not been changed successfully, or has a MediaStreamError object as its argument
                * @deprecated
                * @hidden
                */
            useVideoSource(id: string, successCallback?: Function, failedCallback?: Function): Promise<MediaStream>;
            /**
                * Selects the specified audio output for new calls, use [audioOutputs] to get the list of available audio output.
                * @param {String} id Id of the audio source
                * @deprecated
                * @hidden
                */
            useAudioOutput(id: string): Promise<void>;
            /**
                * Enables microphone/camera if micRequired in [Config] is set to false.
                * @param {Function} successCallback Called if selected recording devices are attached successfully, has MediaStream object as its argument
                * @param {Function} failedCallback Called if selected recording devices cannot be attached, has MediaStreamError object as its argument
                * @deprecated
                * @hidden
                */
            attachRecordingDevice(successCallback?: Function, failedCallback?: Function): Promise<MediaStreamTrack>;
            /**
                * Disables microphone/camera if micRequired in [Config] is set to false.
                * @deprecated
                * @hidden
                */
            detachRecordingDevice(): void;
            /**
                * Sets the call active.
                * @param {VoxImplant.Call} call Voximplant call instance
                * @param {Boolean} [active=true] If true make call active, otherwise make call inactive
                * @deprecated
                * @hidden
                */
            setCallActive(call: Call, active?: boolean): Promise<EventHandlers.Updated>;
            /**
                * Starts/stops sending local video to remote party/parties. *IMPORTANT*: Safari browser for iOS requires a user interface for playing video during a call. It should be interactive element like an HTML "button" with "onclick" handler that calls "play" method on the "video" HTML element.
                * @param {Boolean} [flag=true] Start/stop - true/false
                * @deprecated
                * @hidden
                */
            sendVideo(flag?: boolean): void;
            /**
                * Checks if WebRTC support is available.
                * @returns {Boolean}
                */
            isRTCsupported(): boolean;
            /**
                * Transfers a call. Depending on the result, [CallEvents.TransferComplete] or [CallEvents.TransferFailed] event is dispatched.
                *
                * This method can throw the 1003 error if the client is not connected to the Voximplant Cloud or the 1004 error if the client is not authorized.
                * @param {VoxImplant.Call} call1 The call to transfer
                * @param {VoxImplant.Call} call2 The destination call where the call1 needs to be transferred
                */
            transferCall(call1: Call, call2: Call): void;
            /**
                * Sets the logger levels for specified logger categories.
                * @param {LogCategory} category Log category
                * @param {LogLevel} level Log level
                * @hidden
                */
            setLogLevel(category: LogCategory, level: LogLevel): void;
            /**
                * @hidden
                */
            onSignalingConnected(): void;
            /**
                * @hidden
                */
            onSignalingClosed(): Promise<void>;
            /**
                * @hidden
                */
            onSignalingConnectionFailed(reason: any): void;
            /**
                * @hidden
                */
            onMediaConnectionFailed(): void;
            /**
                * Not documented function for backward compatibility
                * @hidden
                * @param string call_id Call ID
                * @returns {Call}
                */
            getCall(call_id: string): Call;
            /**
                * Not documented function for backward compatibility
                * Remove call from calls array
                * @param string call_id Call id
                * @hidden
                */
            removeCall(call_id: string): void;
            /**
                * Returns promise that is resolved with a boolean flag. The boolean flag.
                * is set to 'true' if screen sharing is supported.
                * Promise is rejected in case of an internal error.
                */
            screenSharingSupported(): Promise<boolean>;
            /**
                * Registers a handler for specified event.
                * @param event Event name (i.e. [Events.SDKReady]). See [Events]
                * @param handler Handler function. A single parameter is passed - object with event information
                * @deprecated
                * @hidden
                */
            addEventListener(event: Events, handler: (ev: any) => void): void;
            /**
                * Removes the handler for specified event
                * @param {Function} event Event name (i.e. [Events.SDKReady]). See [Events]
                * @param {Function} [handler] Handler function, if not specified all event handlers for the specified event are removed
                * @function
                * @deprecated
                * @hidden
                */
            removeEventListener(event: Events, handler?: (ev: any) => void): void;
            /**
                * Registers a handler for the specified event. The method is a shorter equivalent for *addEventListener*. One event can have more than one handler; handlers are executed in order of registration.
                * Use the [Client.off] method to delete a handler.
                * @param {string} event Event name (i.e. [Events.SDKReady]). See [Events]
                * @param {Function} handler Handler function. A single parameter is passed - object with event information
                * @function
                */
            on(event: Events, handler: (ev: any) => void, options?: EventListenerOption): void;
            /**
                * Removes a handler for the specified event. The method is a shorter equivalent for *removeEventListener*. If a number of events has the same function as a handler, the method can be called multiple times with the same handler argument.
                * @param {string} event Event name (i.e. [Events.SDKReady]). See [Events]
                * @param {Function} [handler] Handler function, if not specified all event handlers for the specified event are removed
                * @function
                */
            off(event: Events, handler?: (ev: any) => void): void;
            /**
                * Registers for push notifications. Application receive push notifications from Voximplant Server after first login.
                * @hidden
                * @param token FCM registration token that can be retrieved by calling firebase.messaging().getToken() inside a service worker
                * @returns {Promise<void>}
                */
            registerForPushNotificatuons(token: string): Promise<void>;
            /**
                * Registers for push notifications. Application receive push notifications from Voximplant Server after first login.
                * @param token FCM registration token that can be retrieved by calling firebase.messaging().getToken() inside a service worker
                * @returns {Promise<void>}
                */
            registerForPushNotifications(token: string): Promise<void>;
            /**
                * Unregisters from push notifications. Application no longer receives push notifications from the Voximplant server.
                * @param token FCM registration token that has been used to register for push notifications
                * @hidden
                * @returns {Promise<void>}
                */
            unregisterForPushNotificatuons(token: string): Promise<void>;
            /**
                * Unregisters from push notifications. Application no longer receives push notifications from the Voximplant server.
                * @hidden
                * @param token FCM registration token that has been used to register for push notifications
                * @returns {Promise<void>}
                */
            unregisterForPushNotifications(token: string): Promise<void>;
            /**
                * Handles push notification
                * @param message  Push notification that comes from the firebase.messaging().setBackgroundMessageHandler callback inside a service worker
                * @returns {Promise<void>}
                */
            handlePushNotification(message: any): Promise<void>;
            /**
                * Generates a new GUID identifier. Unique each time.
                * @hidden
                */
            getGUID(): string;
            /**
                * Sets the state of the silent logging inside SDK (it is disabled by default). When it is enabled, the WebSDK saves all logger messages into the logger until you disable it.
                *
                * Note that enabling of the silent logging automatically clears all existed logger records before the start.
                *
                * You can get current logger by the [getSilentLog] function and clean it by the [clearSilentLog] function.
                * @param {boolean} flag
                */
            enableSilentLogging(flag: boolean): void;
            /**
                * Clears the logger journal and free some memory.
                */
            clearSilentLog(): void;
            /**
                * Gets records from the logger journal.
                * @returns {Array<string>}
                */
            getSilentLog(): Array<string>;
            /**
                * Sets outer logging callback.
                *
                * The method allows integrating logging pipeline of the WebSDK into the own logger i.e. the method call sends all events to the function.
                * *IMPORTANT:* the callback strictly ignores Loglevel settings of the WebSDK.
                *
                * @param {{(record: LogRecord): void}} callback
                */
            setLoggerCallback(callback: {
                    (record: LogRecord): void;
            }): void;
            /**
                * Gets current client state
                * @return {ClientState}
                */
            getClientState(): ClientState;
            /**
                * @hidden
                * @deprecated
                * @returns {any}
                */
            setSwfColor(): any;
            /**
                * @hidden
                * @return {string}
                * @private
                */
            _traceName(): string;
            /**
                * @hidden
                */
            setConnectionData(gateway: any, connectionId: any): void;
            /**
                * Specifies the audio codecs that can be used for calls.
                */
            limitAudioCodecs(codecs: CodecDescription[]): Promise<boolean>;
            /**
                * Specifies the video codecs that can be used for calls.
                */
            limitVideoCodecs(codecs: CodecDescription[]): Promise<boolean>;
            get audioMediaTrackTransform(): (originalTrack: MediaStreamTrack) => MediaStreamTrack;
            set audioMediaTrackTransform(transform: (originalTrack: MediaStreamTrack) => MediaStreamTrack);
            get videoMediaTrackTransform(): (originalTrack: MediaStreamTrack) => Promise<MediaStreamTrack>;
            set videoMediaTrackTransform(transform: (originalTrack: MediaStreamTrack) => Promise<MediaStreamTrack>);
    }
}

declare module 'voximplant-websdk/Messaging' {
    import { Messenger as ImplementMessenger } from 'voximplant-websdk/Messaging/src/Messenger';
    import { Conversation as ImplementConversation } from 'voximplant-websdk/Messaging/src/Conversation';
    import { Message as ImplementMessage } from 'voximplant-websdk/Messaging/src/Message';
    import * as Implement from 'voximplant-websdk/Messaging/src/Structures';
    /**
        * Messaging module allows to exchange instant messages between two or more participants.
        * Messaging supports text and metadata. The conversation does not bind or depend on audio/video calls though there is a possibility to integrate messaging in audio/video calls.
        *
        * FEATURES:
        * 1. Messaging is the separate part of WEB SDK but it uses the [Client.login], [Client.loginWithOneTimeKey] and [Client.loginWithToken] methods. In brief, if a user has already been logged in, he can use Messaging functionality.
        * 2. Messaging does not use backend JS scenarios at all.
        *
        */
    export module Messaging {
            /**
                * Get a [Messenger] instance to use Messaging functions.
                */
            function getInstance(): Messenger;
            /**
                * Messenger class is used to control messaging functions. Cannot be instantiated directly (singleton), please use [getMessenger] or [Messaging.get] to get the class instance.
                */
            class Messenger extends ImplementMessenger {
            }
            /**
                * Class that represents a conversation. A Conversation instance is returned by the [Messenger.createConversation] and [Messenger.createConversationFromCache] methods.
                * Provides methods to send messages, manage participants, receive conversation events history etc.
                */
            class Conversation extends ImplementConversation {
            }
            /**
                * Describes single message. Received via the [MessengerEvents.SendMessage] or [MessengerEvents.EditMessage] events and used to serialize or edit the message.
                */
            class Message extends ImplementMessage {
            }
            /**
                * Serialized [Message] that can be stored (e.g. in IndexedDB) and restored later via the [Messenger.createMessageFromCache] method.
                */
            interface SerializedMessage extends Implement.SerializedMessage {
            }
            /**
                * Serialized [Conversation] that can be stored (e.g. in IndexedDB) and restored later via the [Messenger.createConversationFromCache] method.
                */
            interface SerializedConversation extends Implement.SerializedConversation {
            }
            /**
                * Interface that represents a participant of the conversation (see [Conversation.participants].
                * The default permissions for all participants are: write / edit / remove their own messages.
                */
            interface ConversationParticipant extends Implement.ConversationParticipant {
            }
            /**
                * Interface that represents a Voximplant user with Messaging user id.
                * Voximplant users are created in [Voximplant control panel](https://manage.voximplant.com) or via [HTTP API](/docs/references/httpapi).
                * To get user(s) information use the [Messenger.getUser], [Messenger.getUsers], [Messenger.getUserById] and [Messenger.getUsersById] methods.
                */
            interface User extends Implement.User {
            }
            /**
                * Interface that represents user subscription information. Available in the [MessengerEvents.GetSubscriptionList] event.
                */
            interface UserSubscriptions extends Implement.MsgOutput.UserSubscriptions {
            }
            /**
                * Interface that represents user status information. Available in the [MessengerEvents.SetStatus] event.
                */
            interface UserStatus extends Implement.MsgInOutput.PresenceMessage {
            }
            /**
                * Enum that represents actions that trigger messenger events.
                * Each action is the reason for every triggered event and is specified in the [EventHandlers.MessengerEvent.messengerAction] property.
                */
            enum MessengerAction {
                    /**
                        * @hidden
                        */
                    UNKNOWN = "UNKNOWN",
                    createConversation = "createConversation",
                    editConversation = "editConversation",
                    /**
                        * @hidden
                        */
                    removeConversation = "removeConversation",
                    joinConversation = "joinConversation",
                    leaveConversation = "leaveConversation",
                    getConversation = "getConversation",
                    getConversations = "getConversations",
                    getPublicConversations = "getPublicConversations",
                    /**
                        * @hidden
                        */
                    searchConversations = "searchConversations",
                    /**
                        * @hidden
                        */
                    removeEmptyConversation = "removeEmptyConversation",
                    addParticipants = "addParticipants",
                    editParticipants = "editParticipants",
                    removeParticipants = "removeParticipants",
                    getUser = "getUser",
                    getUsers = "getUsers",
                    editUser = "editUser",
                    setStatus = "setStatus",
                    sendMessage = "sendMessage",
                    editMessage = "editMessage",
                    removeMessage = "removeMessage",
                    typingMessage = "typingMessage",
                    isRead = "isRead",
                    subscribe = "subscribe",
                    unsubscribe = "unsubscribe",
                    manageNotification = "manageNotification",
                    getSubscriptionList = "getSubscriptionList",
                    /**
                        * @hidden
                        */
                    createBot = "createBot",
                    /**
                        * @hidden
                        */
                    removeBot = "removeBot",
                    retransmitEvents = "retransmitEvents"
            }
            /**
                * Enum that represents types of messenger events.
                * @event
                */
            enum MessengerEvents {
                    /**
                        * Triggered when any user has created a new conversation with the current user in the participant array.
                        */
                    CreateConversation = "CreateConversation",
                    /**
                        * Triggered when conversation the current user belongs to wat modified.
                        */
                    EditConversation = "EditConversation",
                    /**
                        * @hidden
                        * @deprecated
                        * The conversation is removed.
                        */
                    RemoveConversation = "RemoveConversation",
                    /**
                        * Triggered when the [Messenger.getConversation] or [Messenger.getConversations] has been called by the current user.
                        */
                    GetConversation = "GetConversation",
                    /**
                        * Triggered when the [Conversation.GetPublicConversations] method has been called by the current user.
                        */
                    GetPublicConversations = "GetPublicConversations",
                    /**
                        * Triggered when a new message has been sent to a conversation via the [Conversation.sendMessage] method by any conversation participant.
                        */
                    SendMessage = "SendMessage",
                    /**
                        * Triggered when a message has been edited via the [Message.update] method by any conversation participant.
                        */
                    EditMessage = "EditMessage",
                    /**
                        * Triggered when a message has been removed via the [Message.remove] method by any conversation participant.
                        */
                    RemoveMessage = "RemoveMessage",
                    /**
                        * Triggered when any participant of a conversation the current user belongs to has called the [Conversation.typing] method.
                        */
                    Typing = "Typing",
                    /**
                        * Triggered when the information about the user which the current user is subscribed to or the information about the current user has been changed via the [Messenger.editUser] method.
                        */
                    EditUser = "EditUser",
                    /**
                        * Triggered when the [Messenger.getUser], [Messenger.getUsers], [Messenger.getUserById] or [Messenger.getUsersById] method has been called by the current user.
                        */
                    GetUser = "GetUser",
                    /**
                        * Triggered when error occurs. Refer to the error codes in the [MessengerError] enum.
                        */
                    Error = "Error",
                    /**
                        * Triggered when the [Conversation.retransmitEvents] method has been called by the current user.
                        */
                    RetransmitEvents = "RetransmitEvents",
                    /**
                        * Triggered when any participant of a conversation the current user belongs to called the [Conversation.markAsRead] method.
                        */
                    Read = "Read",
                    /**
                        * Triggered when the [Messenger.subscribe] method has been called by the current user.
                        */
                    Subscribe = "Subscribe",
                    /**
                        * Triggered when the [Messenger.unsubscribe] method has been called by the current user.
                        */
                    Unsubscribe = "Unsubscribe",
                    /**
                        * Triggered when any user the current user is subscribed to or the current user called the [Messenger.setStatus] method.
                        */
                    SetStatus = "SetStatus",
                    /**
                        * Triggered when the [Messenger.getSubscriptionList] method has been called by the current user.
                        */
                    GetSubscriptionList = "GetSubscriptionList",
                    /**
                        * @hidden
                        */
                    CreateBot = "CreateBot",
                    /**
                        * @hidden
                        */
                    RemoveBot = "RemoveBot"
            }
            enum MessengerError {
                    /**
                        *  Something went wrong. Please check the input or required parameters.
                        */
                    Error_0 = 0,
                    /**
                        * Transport message structure is wrong. From GW.
                        */
                    Error_1 = 1,
                    /**
                        * Event name is unknown.
                        */
                    Error_2 = 2,
                    /**
                        * User is not authorized. From GW.
                        */
                    Error_3 = 3,
                    /**
                        * Conversation does not exist.
                        */
                    Error_8 = 8,
                    /**
                        * Message with this UUID does not exist in the conversation.
                        */
                    Error_10 = 10,
                    /**
                        *  Message with this UUID is deleted from the conversation.
                        */
                    Error_11 = 11,
                    /**
                        *  ACL error.
                        */
                    Error_12 = 12,
                    /**
                        *  User is already in the participants list.
                        */
                    Error_13 = 13,
                    /**
                        *  Public join is not available for this conversation.
                        */
                    Error_15 = 15,
                    /**
                        *  Conversation with this UUID is deleted.
                        */
                    Error_16 = 16,
                    /**
                        *  User validation error.
                        */
                    Error_18 = 18,
                    /**
                        *  User is not in the participants list.
                        */
                    Error_19 = 19,
                    /**
                        *  Number of requested objects is 0 or larger than allowed by the service.
                        */
                    Error_21 = 21,
                    /**
                        *  Number of requested objects is larger than allowed by the service.
                        */
                    Error_22 = 22,
                    /**
                        *  Message size exceeds the limit of 5000 symbols.
                        */
                    Error_23 = 23,
                    /**
                        *  The 'seq' parameter value is greater than currently possible.
                        */
                    Error_24 = 24,
                    /**
                        *  User is not found.
                        */
                    Error_25 = 25,
                    /**
                        *  The notification event is incorrect.
                        */
                    Error_26 = 26,
                    /**
                        *  The 'from' field value is greater than the 'to' field value.
                        */
                    Error_28 = 28,
                    /**
                        *  Messaging service is not available. Try again later. From GW.
                        */
                    Error_30 = 30,
                    /**
                        *  N messages per second limit reached. Please try again later. From GW.
                        */
                    Error_32 = 32,
                    /**
                        *  N messages per minute limit reached. Please try again later. From GW.
                        */
                    Error_33 = 33,
                    /**
                        *  Direct conversation cannot be public or uber.
                        */
                    Error_34 = 34,
                    /**
                        *  Direct conversation is allowed between two users only.
                        */
                    Error_35 = 35,
                    /**
                        *  Passing the 'eventsFrom', 'eventsTo' and 'count' parameters simultaneously is not allowed. You should use only two of them.
                        */
                    Error_36 = 36,
                    /**
                        *  Adding participant to a direct conversation is not allowed.
                        */
                    Error_37 = 37,
                    /**
                        *  Removing participant from a direct conversation is not allowed.
                        */
                    Error_38 = 38,
                    /**
                        *  Joining a direct conversation is not allowed.
                        */
                    Error_39 = 39,
                    /**
                        *  Leaving a direct conversation is not allowed.
                        */
                    Error_40 = 40,
                    /**
                        *  Specify at least two parameters: eventsFrom, eventsTo or count.
                        */
                    Error_41 = 41,
                    /**
                        *  Current messaging tier has been exceeded.
                        */
                    Error_42 = 42,
                    /**
                        *  Messaging tier is being upgraded. Please try again later.
                        */
                    Error_43 = 43,
                    /**
                        *  The legacy format is not supported
                        */
                    Error_44 = 44,
                    /**
                        *  Internal error.
                        */
                    Error_500 = 500,
                    /**
                        * Invalid argument(s).
                        */
                    Error_10001 = 10001,
                    /**
                        * Response timeout.
                        */
                    Error_10002 = 10002
            }
            module EventHandlers {
                    /**
                        * Interface that represents all messenger events which are passed
                        * - as a resolve value by all [Messenger], [Conversation] and [Message] methods that return a Promise
                        * - as an argument to a callback function registered via the [Messenger.on] method
                        */
                    interface MessengerEvent {
                            /**
                                * Messaging user id of the user that initiated the event.
                                */
                            initiator: number;
                            /**
                                * [MessengerAction] which is the reason the event has been triggered.
                                */
                            messengerAction: MessengerAction;
                            /**
                                * Optional. Messenger request UUID.
                                * There's no requestUuid only in [EventHandlers.RetransmittedEvent] and in [EventHandlers.ErrorEvent] when the actual request has not been made due to an invalid payload.
                                */
                            requestUuid?: string;
                            /**
                                * Optional. UNIX timestamp (seconds) that specifies the time the event has been dispatched by the cloud.
                                */
                            timestamp?: number;
                    }
                    /**
                        * Interface that represents the event passed
                        * - as a resolve value by the [Messenger.getConversation] and [Messenger.getConversations]
                        * - as an argument to a callback function registered for the [MessengerEvents.GetConversation] event
                        */
                    interface GetConversationEvent extends MessengerEvent {
                            /**
                                * [Conversation].
                                */
                            conversation: Conversation;
                    }
                    /**
                        * Interface that represents the event passed
                        * - as a resolve value by the [Messenger.getPublicConversations] method
                        * - as an argument to a callback function registered for the [MessengerEvents.GetPublicConversations] event
                        */
                    interface GetPublicConversationsEvent extends MessengerEvent {
                            /**
                                * Array of conversation UUIDs.
                                */
                            conversations: Array<string>;
                    }
                    /**
                        * Interface that represents the event passed
                        * - as a resolve value by the [Messenger.createConversation] method
                        * - as an argument to a callback function registered for the [MessengerEvents.CreateConversation] event
                        */
                    interface CreateConversationEvent extends MessengerEvent {
                            /**
                                * The created conversation.
                                */
                            conversation: Conversation;
                    }
                    /**
                        * Interface that represents the event passed
                        * - as a resolve value by the [Conversation.addParticipants], [Conversation.editParticipants], [Conversation.removeParticipants], [Conversation.setTitle], [Conversation.setPublicJoin], [Conversation.setCustomData] and [Conversation.update] methods
                        * - as an argument to a callback function registered for the [MessengerEvents.EditConversation] event
                        */
                    interface EditConversationEvent extends MessengerEvent {
                            /**
                                * Conversation uuid.
                                */
                            uuid: Conversation;
                            /**
                                * Sequence of this event.
                                */
                            seq: number;
                    }
                    /**
                        * Interface that represents the event passed
                        * - as a resolve value by the **Conversation.removeConversation** method
                        * - as an argument to a callback function registered for the [MessengerEvents.RemoveConversation] event
                        * @deprecated
                        * @hidden
                        */
                    interface RemoveConversationEvent extends MessengerEvent {
                            /**
                                * Conversation uuid.
                                */
                            uuid: string;
                            /**
                                * Sequence of this event.
                                */
                            seq: number;
                    }
                    /**
                        * Interface that represents the event passed
                        * - as a resolve value by the [Messenger.getUser], [Messenger.getUsers], [Messenger.getUserById] and [Messenger.getUsersById] methods
                        * - as an argument to a callback function registered for the [MessengerEvents.GetUser] event
                        */
                    interface GetUserEvent extends MessengerEvent {
                            /**
                                * The user object.
                                */
                            user: User;
                    }
                    /**
                        * Interface that represents the event passed
                        * - as a resolve value by the [Messenger.editUser] method
                        * - as an argument to a callback function registered for the [MessengerEvents.EditUser] event
                        */
                    interface EditUserEvent extends MessengerEvent {
                            /**
                                * The edited user object.
                                */
                            user: User;
                    }
                    /**
                        * Interface that represents the event passed
                        * - as a resolve value by the [Messenger.setStatus] method
                        * - as an argument to a callback function registered for the [MessengerEvents.SetStatus] event
                        */
                    interface SetStatusEvent extends MessengerEvent {
                            /**
                                * Whether the user is online.
                                */
                            online: boolean;
                    }
                    /**
                        * Interface that represents the event passed
                        * - as a resolve value by the [Messenger.subscribe] method
                        * - as an argument to a callback function registered for the [MessengerEvents.Subscribe] event
                        */
                    interface SubscribeEvent extends MessengerEvent {
                            /**
                                * Array of Messaging user ids.
                                */
                            users: Array<number>;
                    }
                    /**
                        * Interface that represents the event passed
                        * - as a resolve value by the [Messenger.unsubscribe] method
                        * - as an argument to a callback function registered for the [MessengerEvents.Unsubscribe] event
                        */
                    interface UnsubscribeEvent extends MessengerEvent {
                            /**
                                * Array of Messaging user ids.
                                */
                            users: number[];
                    }
                    /**
                        * Interface that represents the event passedMessngerEvents
                        * - as a resolve value by the [Messenger.getSubscriptionList] method
                        * - as an argument to a callback function registered for the [MessengerEvents.GetSubscriptionList] event
                        */
                    interface GetSubscriptionListEvent extends MessengerEvent {
                            /**
                                * Array of Messaging user ids.
                                */
                            users: Array<number>;
                    }
                    /**
                        * Interface that represents the event passed
                        * - as a resolve value by the [Conversation.sendMessage] method
                        * - as an argument to a callback function registered for the [MessengerEvents.SendMessage] event
                        */
                    interface SendMessageEvent extends MessengerEvent {
                            /**
                                * Message object.
                                */
                            message: Message;
                            /**
                                * Sequence of this event.
                                */
                            seq: number;
                    }
                    /**
                        * Interface that represents the event passed
                        * - as a resolve value by the [Message.update] method
                        * - as an argument to a callback function registered for the [MessengerEvents.EditMessage] event
                        */
                    interface EditMessageEvent extends MessengerEvent {
                            /**
                                * Edited message object.
                                */
                            message: Message;
                            /**
                                * Sequence of this event.
                                */
                            seq: number;
                    }
                    /**
                        * Interface that represents the event passed
                        * - as a resolve value by the [Message.remove] method
                        * - as an argument to a callback function registered for the [MessengerEvents.RemoveMessage] event
                        */
                    interface RemoveMessageEvent extends MessengerEvent {
                            /**
                                * Message UUID.
                                */
                            uuid: string;
                            /**
                                * Sequence of this event.
                                */
                            seq: number;
                    }
                    /**
                        * Interface that represents the event passed
                        * - as a resolve value by the [Conversation.typing] method
                        * - as an argument to a callback function registered for the [MessengerEvents.Typing] event
                        */
                    interface TypingEvent extends MessengerEvent {
                            /**
                                * Conversation UUID.
                                */
                            conversation: string;
                    }
                    /**
                        * Interface that represents the event passed
                        * - as a resolve value by the [Conversation.markAsRead] method
                        * - as an argument to a callback function registered for the [MessengerEvents.Read] event
                        */
                    interface ReadEvent extends MessengerEvent {
                            /**
                                * Conversation UUID.
                                */
                            conversation: string;
                            /**
                                * Sequence of this event.
                                */
                            seq: number;
                    }
                    /**
                        * Interface that represents the event passed
                        * - as a resolve value by the [Conversation.retransmitEvents] method
                        * - as an argument to a callback function registered for the [MessengerEvents.RetransmitEvents] event
                        */
                    interface RetransmitEventsEvent extends MessengerEvent {
                            /**
                                * Array of retransmitted events.
                                */
                            events: Array<RetransmittedEvent>;
                    }
                    /**
                        * Interface that represents a single event in the array of retransmitted events passed in [EventHandlers.RetransmitEventsEvent]
                        * - by the [Conversation.retransmitEvents] method
                        * - to a callback function registered for the [MessengerEvents.RetransmitEvents] event
                        */
                    interface RetransmittedEvent extends MessengerEvent {
                            /**
                                * Optional. Conversation object. Only in Conversation events.
                                */
                            conversation?: Conversation;
                            /**
                                * Optional. Message object. Only in Message events.
                                */
                            message?: Message;
                            /**
                                * Sequence of this event.
                                */
                            seq: number;
                    }
                    interface ErrorEvent extends MessengerEvent {
                            /**
                                * Messaging error code.
                                */
                            code: MessengerError;
                            /**
                                * Human-readable error description.
                                */
                            description: string;
                    }
            }
            /**
                * @hidden
                */
            type MessengerEventsPayload<E extends MessengerEvents> = EventHandlers.MessengerEvent & MessengerEventPayloads[E];
            /**
                * @hidden
                */
            interface MessengerEventPayloads {
                    CreateConversation: EventHandlers.CreateConversationEvent;
                    EditConversation: EventHandlers.EditConversationEvent;
                    RemoveConversation: EventHandlers.RemoveConversationEvent;
                    GetConversation: EventHandlers.GetConversationEvent;
                    GetPublicConversations: EventHandlers.GetPublicConversationsEvent;
                    SendMessage: EventHandlers.SendMessageEvent;
                    EditMessage: EventHandlers.EditMessageEvent;
                    RemoveMessage: EventHandlers.RemoveMessageEvent;
                    Typing: EventHandlers.TypingEvent;
                    GetUser: EventHandlers.GetUserEvent;
                    EditUser: EventHandlers.EditUserEvent;
                    Read: EventHandlers.ReadEvent;
                    Subscribe: EventHandlers.SubscribeEvent;
                    Unsubscribe: EventHandlers.UnsubscribeEvent;
                    SetStatus: EventHandlers.SetStatusEvent;
                    GetSubscriptionList: EventHandlers.GetSubscriptionListEvent;
                    ManageNotifications: EventHandlers.EditUserEvent;
                    CreateBot: {};
                    RemoveBot: {};
                    RetransmitEvents: EventHandlers.RetransmitEventsEvent;
                    Error: EventHandlers.ErrorEvent;
            }
    }
    export default Messaging;
}

declare module 'voximplant-websdk/Events' {
    /**
        * The events that are triggered by [Client] instance. See the [getInstance] method.
        * @event
        */
    export enum Events {
            /**
                * Triggered after SDK has been successfully initialized after the [Client.init] function call
                * @cast EventHandlers.SDKReady
                */
            SDKReady,
            /**
                * Triggered after connection to the Voximplant Cloud has been established successfully.
                *
                * @see [Client.connect]
                */
            ConnectionEstablished,
            /**
                * Triggered if a connection to the Voximplant cloud could not be established.
                * @see [Client.connect]
                * @cast EventHandlers.ConnectionFailed
                */
            ConnectionFailed,
            /**
                * Triggered if a connection to Voximplant Cloud has been closed because of network problems or the [Client.disconnect] function call.
                * @see [Client.connect], [Client.disconnect]
                */
            ConnectionClosed,
            /**
                * Triggered when the SDK client loses connection with the Voximplant cloud and tries to reconnect, for example, when a customer's internet connection fails.
                */
            Reconnecting,
            /**
                * Triggered when reconnection to the server is successful.
                */
            Reconnected,
            /**
                * Triggered after the [Client.login], [Client.loginWithOneTimeKey] and [Client.loginWithToken] methods call.
                * @cast EventHandlers.AuthResult
                */
            AuthResult,
            /**
                * Triggered after the [LoginTokens.refreshToken] call
                * @cast EventHandlers.AuthTokenResult
                */
            RefreshTokenResult,
            /**
                * Triggered after sound playback has been stopped.
                * @see [Client.playToneScript], [Client.stopPlayback]
                */
            PlaybackFinished,
            /**
                * @cast EventHandlers.MicAccessResult
                */
            MicAccessResult,
            /**
                *    Triggered when there is a new incoming call to current user
                *
                * @cast EventHandlers.IncomingCall
                */
            IncomingCall,
            /**
                * Triggered when audio and video sources information has been updated.
                *    See the [Client.audioSources] and [Client.videoSources] for details
                * @hidden
                * @deprecated
                */
            SourcesInfoUpdated,
            /**
                * @hidden
                * @deprecated
                */
            NetStatsReceived,
            /**
                * @hidden
                */
            SIPRegistrationSuccessful,
            /**
                * @hidden
                */
            SIPRegistrationFailed,
            /**
                * Triggered when a contact center agent's status changes via SDK or within the contact center. Works both for SmartQueue and ACD v1.
                * @cast EventHandlers.ACDStatusEvent
                */
            ACDStatusUpdated,
            /**
                * Triggered when SmartQueue messaging status of current user changed from SDK or from inside the SmartQueue messaging service.
                * @cast EventHandlers.ACDStatusEvent
                */
            SQMessagingStatusUpdated,
            /**
                * Triggered when the Web SDK detects incorrect usage of the ACD module, e.g., usage of the same credentials in the different browsers or multiple browser windows. This event can also trigger when you make a request, reload the page and receive response after the page reloads.
                * @cast EventHandlers.ACDErrorEvent
                */
            ACDError,
            /**
                * Triggered when the Web SDK detects incorrect use of the SmartQueue module, e.g.,
                * Using the same credentials in the different browsers or multiple browser's windows.
                * @cast EventHandlers.SQErrorEvent
                */
            SQError,
            PlaybackError
    }
}

declare module 'voximplant-websdk/Call/CallEvents' {
    /**
        * The events that are triggered by [Call] instance.
        *
        * Use [Call.on] to subscribe on
        * any of these events.
        * @event
        */
    export enum CallEvents {
            /**
                * Trigerred after the call is connected from the signaling perspective. Depending on network conditions there can be a 2-3 seconds delay between first audio data and this event.
                * @cast EventHandlers.CallEventWithHeaders
                */
            Connected,
            /**
                * Triggered when a call has been disconnected
                *
                * @cast EventHandlers.CallEventWithHeaders
                */
            Disconnected,
            /**
                *  Triggered due to a call failure
                *
                *  Most frequent status codes:
                *
                * |Code|Description                      |
                * |----|---------------------------------|
                * |486 |Destination number is busy       |
                * |487 |Request terminated               |
                * |603 |Call has been rejected           |
                * |404 |Invalid number                   |
                * |480 |Destination number is unavailable|
                * |402 |Insufficient funds               |
                *
                * @cast EventHandlers.Failed
                */
            Failed,
            /**
                * Triggered when the [Call.ring](/docs/references/voxengine/call#ring) method is called on the scenario side.
                *
                * Usually, this event is triggered when the call is arrived to its destination. After receiving this event, the application should start playing progress tones.
                * @cast EventHandlers.CallEvent
                */
            ProgressToneStart,
            /**
                * Triggered when the [Call.answer](/docs/references/voxengine/call#answer) or [Call.startEarlyMedia](/docs/references/voxengine/call#startearlymedia) method is called on the scenario side.
                *
                * After receiving this event, the application should stop playing progress tones if they have been playing after the [ProgressToneStart](/docs/references/websdk/voximplant/callevents#progresstonestart) event.
                * @cast EventHandlers.CallEvent
                */
            ProgressToneStop,
            /**
                * Triggered when a text message is received.
                * @cast EventHandlers.MessageReceived
                */
            MessageReceived,
            /**
                * Triggered when the INFO message is received
                * @cast EventHandlers.InfoReceived
                */
            InfoReceived,
            /**
                * Triggered when a call has been transferred successfully.
                * @cast EventHandlers.CallEvent
                */
            TransferComplete,
            /**
                *  Triggered when a call transfer failed
                * @cast EventHandlers.CallEvent
                */
            TransferFailed,
            /**
                * Triggered when connection has not been established due to a network connection problem between 2 peers
                * @cast EventHandlers.CallEvent
                * @deprecated
                */
            ICETimeout,
            /**
                *  Triggered every 10 seconds when the call is CONNECTED.
                *  Handler function receives RTCStatsReport dictionary as it is returned by a browser RTCPeerConnection.getStats() method as an argument.
                *  RTCStatsReport provides statistics about the specified [Call] and may differ from one vendor to another.
                *  @deprecated
                */
            RTCStatsReceived,
            /**
                * Triggered when the call statistics are received. The collection interval is specified in [Config.rtcStatsCollectionInterval] (defaults to 10 seconds).
                * @see [Config.rtcStatsCollectionInterval]
                * @cast EventHandlers.CallStatsReceived
                */
            CallStatsReceived,
            /**
                * Triggered when a new HTMLMediaElement for the call's media playback has been created
                * Handler function receives [EventHandlers.MediaElementCreated] object as an argument.
                * @hidden
                * @deprecated
                */
            MediaElementCreated,
            /**
                * @hidden
                * @deprecated
                */
            MediaElementRemoved,
            /**
                * Triggered when an ICE connection is complete
                * @deprecated
                * @cast EventHandlers.CallEvent
                */
            ICECompleted,
            /**
                * Triggered when a call has been updated. For example, video has been added/removed.
                * Handler function receives the [EventHandlers.Updated] object as an argument.
                * @cast EventHandlers.Updated
                */
            Updated,
            /**
                * Triggered when user receives the call update from another side. For example, a video has been added/removed on the remote side.
                * Handler function receives [EventHandlers.CallEvent] object as an argument.
                * @hidden
                * @deprecated
                */
            PendingUpdate,
            /**
                * Triggered when multiple participants tried to update the same call simultaneously. For example, video added/removed on a local and remote side at the same time.
                * Handler function receives [EventHandlers.UpdateFailed] object as an argument.
                * @hidden
                * @deprecated
                */
            UpdateFailed,
            /**
                * Handler function receives [EventHandlers.LocalVideoStreamAdded] object as an argument.
                * @deprecated
                * @hidden
                */
            LocalVideoStreamAdded,
            /**
                * Triggered when a new Endpoint is created. [Endpoint] represents another participant in the call or conference.
                *
                * This event is not triggered if a user connects via [joinAsViewer](/docs/references/websdk/voximplant/client#joinasviewer).
                * @cast EventHandlers.EndpointHandler
                */
            EndpointAdded,
            /**
                * Triggered when an [Endpoint] is removed. E.g. when a participant leaves the conference or [player](/docs/references/voxengine/player) is removed.
                * @cast EventHandlers.EndpointHandler
                */
            EndpointRemoved,
            /**
                * @cast EventHandlers.StateUpdated
                */
            StateUpdated,
            /**
                * @cast EventHandlers.ActiveUpdated
                */
            ActiveUpdated,
            /**
                * Triggered when the local audio, video or shared stream is encoded by a codec different from the one specified in [Config] or [CallSettings].
                * @hidden
                * @cast EventHandlers.CodecMismatchIssue
                */
            QualityIssueCodecMismatch,
            /**
                * Triggered when a network-based media latency is detected in the call.
                * @hidden
                * @beta
                * @cast EventHandlers.HighMediaLatencyIssue
                */
            QualityIssueHighMediaLatency,
            /**
                * Triggered when the ICE connection is switched to the "disconnected" state during the call.
                * @hidden
                * @beta
                * @cast EventHandlers.ICEDisconnectedIssue
                */
            QualityIssueICEDisconnected,
            /**
                * Triggered when the video resolution sent is lower than a captured video resolution.
                * @beta
                * @hidden
                * @cast EventHandlers.LocalVideoDegradationIssue
                */
            QualityIssueLocalVideoDegradation,
            /**
                * Triggered when the current bitrate is insufficient for sending video in the current resolution.
                * @beta
                * @hidden
                */
            QualityIssueLowBandwidth,
            /**
                * Triggered when no audio is captured by the microphone.
                * @beta
                * @hidden
                */
            QualityIssueNoAudioSignal,
            /**
                * Triggered every 2.5 seconds and indicates packet loss for the last period.
                * @beta
                * @hidden
                * @cast EventHandlers.PacketLossIssue
                */
            QualityIssuePacketLoss,
            /**
                * Triggered when screen sharing is stopped
                */
            SharingStopped
    }
}

declare module 'voximplant-websdk/Call/EndPoints/Endpoint' {
    import { EventTarget } from 'voximplant-websdk/EventTarget';
    import { EndpointEvents } from 'voximplant-websdk/Call/EndPoints/EndpointEvents';
    import { MediaRenderer } from 'voximplant-websdk/Media/MediaRenderer';
    import { EndpointInfoData } from 'voximplant-websdk/Call/EndpointListDescription';
    /**
        * Interface that represents any remote media unit in a call. Current endpoints can be retrieved via the [Call.getEndpoints] method.
        *
        * Endpoint can be:
        * <ol>
        * <li><a href="/docs/references/voxengine/asr">ASR</a></li>
        * <li><a href="/docs/references/voxengine/recorder">Recorder</a></li>
        * <li><a href="/docs/references/voxengine/player">Player</a></li>
        * <li> or another <a href="/docs/references/voxengine/call">call</a> (e.g. which is joined to the conference)</li>
        * </ol>
        */
    export class Endpoint extends EventTarget<EndpointEvents> {
            /**
                * @hidden
                */
            isDefault: boolean;
            /**
                * Unique ID of current Endpoint
                */
            id: string;
            /**
                * The list of all media renderers.
                */
            mediaRenderers: MediaRenderer[];
            /**
                * Get <a href="https://tools.ietf.org/html/rfc3261#section-19.1.1" target="_blank">SIP URI</a> of the endpoint
                */
            sipUri: string;
            /**
                * Get user display name of the endpoint.
                */
            displayName: string;
            /**
                * Get user name of the endpoint.
                */
            userName: string;
            /**
                * @hidden
                */
            wasAdded: boolean;
            /**
                * Enables all the endpoints media renderers
                * @see [MediaRenderer.enable]
                */
            enableAll(): void;
            /**
                * Disables all the endpoints media renderers
                * @see [MediaRenderer.disable]
                */
            disableAll(): void;
            /**
                * @hidden
                */
            constructor(
            /**
                * @hidden
                */
            isDefault?: boolean);
            /**
                * @hidden
                */
            place: number;
            /**
                * Set audio output device for current Endpoint. Now supported by Google Chrome only
                * @param {string} id
                */
            useAudioOutput(id: string): void;
            /**
                * @hidden
                */
            updateInfo(data: EndpointInfoData): void;
            /**
                * @hidden
                * @return {string}
                * @private
                */
            _traceName(): string;
    }
}

declare module 'voximplant-websdk/Call/EndPoints/EndpointEvents' {
    /**
        * Events that are triggered when [Endpoint] is updated/edited, removed or started/stopped to receive stream from another [Endpoint].
        * @event
        */
    export enum EndpointEvents {
            /**
                * Triggered when an [Endpoint] is updated/edited. E.g. when
                * a display name is changed via the [setDisplayName](/docs/references/voxengine/conference/endpoint#setdisplayname) method.
                * @cast EventHandlers.EndpointHandler
                */
            InfoUpdated = "InfoUpdated",
            /**
                * Triggered when an [Endpoint] is removed. E.g. when a participant left the conference or [player](/docs/references/voxengine/player) has been removed.
                * @deprecated Use [CallEvents.EndpointRemoved] instead
                * @cast EventHandlers.EndpointHandler
                */
            Removed = "Removed",
            /**
                * Triggered when an Endpoint started to receive an audio / video / screensharing stream from another [Endpoint].
                * __IMPORTANT__: if you subscribe to the event, Web SDK no longer renders remote audio/video stream automatically; you have to render remote streams manually via the [MediaRenderer.render] method.
                * @cast EventHandlers.EndpointMediaHandler
                */
            RemoteMediaAdded = "RemoteMediaAdded",
            /**
                * Triggered when an [Endpoint] stopped to receive an audio / video / screensharing stream from another [Endpoint].
                * @cast EventHandlers.EndpointMediaHandler
                */
            RemoteMediaRemoved = "RemoteMediaRemoved",
            /**
                * Triggered when an [Endpoint]s audio / video / screensharing stream changes. For example, a participant changes their camera
                * @cast EventHandlers.EndpointMediaHandler
                */
            RemoteMediaUpdated = "RemoteMediaUpdated",
            /**
                * @hidden
                */
            RTCStatsReceived = "RTCStatsReceived",
            /**
                * Triggered when voice activity is detected
                * @cast EventHandlerspVoiceStart
                */
            VoiceStart = "VoiceStart",
            /**
                * Triggered when voice activity is ended
                * @cast EventHandlers['VoiceEnd']
                */
            VoiceEnd = "VoiceEnd",
            /**
                * Triggered when the media renderer is disabled.
                * @cast EventHandlers.MediaRenderDisabled
                */
            MediaRenderDisabled = "MediaRenderDisabled",
            /**
                * Triggered when the media renderer is enabled.
                * @cast EventHandlers.MediaRenderEnabled
                */
            MediaRenderEnabled = "MediaRenderEnabled"
    }
}

declare module 'voximplant-websdk/Structures' {
    import { TrackType } from 'voximplant-websdk/Types';
    import { CallMode, CallState } from 'voximplant-websdk/Call/AbstractCall';
    import { LogCategory, LogLevel } from 'voximplant-websdk/Logger';
    /**
        * Voximplant SDK Configuration
        */
    export interface Config {
            /**
                * Optional. Whether to reconnect to IM subsystem automatically
                * @hidden
                */
            imAutoReconnect?: boolean;
            /**
                * Optional. Interval (ms) before reconnect
                * @hidden
                */
            imReconnectInterval?: number;
            /**
                * Optional. Whether to use the XSS protection for incoming instant messages that can contain HTML content
                * @hidden
                */
            imXSSprotection?: boolean;
            /**
                * Optional. Whether the microphone access dialog is shown and all functions become available only after user grants access
                */
            micRequired?: boolean;
            /**
                * Optional. Whether to play the progress tones automatically by means of SDK according to specified progressToneCountry. The default value is true.
                */
            progressTone?: boolean;
            /**
                * COptional. ountry code for progress tone generated automatically if *progressTone* is set to true. Available values are: RU, US
                */
            progressToneCountry?: string;
            /**
                * Optional. Whether to show trace in console. The default value is false.
                */
            enableTrace?: boolean;
            /**
                * Optional. Whether to show debug info in console. The default value is false.
                */
            showDebugInfo?: boolean;
            /**
                * Optional. Whether to show warnings. The default value is true.
                */
            showWarnings?: boolean;
            /**
                * Optional. Whether to apply the default constraints on the next attachRecordingDevice function call or if micRequired set to true.
                * *IMPORTANT*: the value has to be the [VideoSettings] object. *Boolean* values exist only in order to ensure backward compatibility.
                */
            videoConstraints?: VideoSettings | boolean;
            /**
                * Optional. IP address of particular media gateway for connection
                * @hidden
                */
            serverIp?: Array<string> | string;
            /**
                * Node the Voximplant account belongs to. To find which node your account belongs to, log in to your [control panel](https://manage.voximplant.com/?utm_source=docs&utm_medium=node-notice&utm_campaign=gettingstarted) and see the "Credentials for working with API, SDK, SIP" section on the main dashboard.
                */
            node?: ConnectionNode;
            /**
                * Optional. Id of HTMLElement that is used as a default container for local video elements, i.e. caller could see himself in this container during the conversation. Local videos are appended to the body element by default.
                *
                * @deprecated
                */
            videoContainerId?: string;
            /**
                * Optional. Id of HTMLElement that is used as a default container for remote video elements. Remote videos are appended to the body element by default
                *
                */
            remoteVideoContainerId?: string;
            /**
                * Optional. Id of HTMLElement that is used as a default container for local video elements. Local videos are appended to the body element by default
                *
                */
            localVideoContainerId?: string;
            /**
                * *DEPRECATED*
                * Optional. Request video access rights immediately.
                * @deprecated
                * @hidden
                */
            videoSupport?: boolean;
            /**
                * Optional. Set sdk protocol manual. Can be "2" or "3"
                * @hidden
                */
            protocolVersion?: string;
            /**
                * Optional. Whether to use H264 video codec, if available on the target device
                */
            H264first?: boolean;
            /**
                * Optional. RTC statistics collection interval in milliseconds.
                *
                * The default value is 1000.
                *
                * The value should be multiple of 500. If the value is not multiple of 500, it is rounded to the nearest lower suitable value.
                * The minimum value is 500. If set to 0, the statistics are not collected.
                *
                * Energy saver option: if the device's battery is lower than 30% and the device is not connected to a power outlet, the default value is 10000.
                */
            rtcStatsCollectionInterval?: number;
            /**
                * Optional. Whether to use VP8 video codec, if exist
                * @hidden
                */
            VP8first?: boolean;
            /**
                * @hidden
                */
            prettyPrint?: boolean;
            /**
                * @hidden
                * @deprecated
                */
            experiments?: any;
            /**
                * @hidden
                */
            tryingServers?: Array<string>;
            /**
                * Optional. Queue type: ACD or SmartQueue.
                */
            queueType?: QueueTypes;
            /**
                * Enforce use turn serves for conference calls
                * If value is false turn servers possible, but not guarantee
                * @type {boolean}
                * @default false
                * @hidden
                */
            allowTurnForConferenceCalls?: boolean;
            /**
                * @hidden
                */
            features?: string[];
    }
    /**
        * Possible node enumeration values the Voximplant account belongs to.
        */
    export enum ConnectionNode {
            NODE_1 = "NODE_1",
            NODE_2 = "NODE_2",
            NODE_3 = "NODE_3",
            NODE_4 = "NODE_4",
            NODE_5 = "NODE_5",
            NODE_6 = "NODE_6",
            NODE_7 = "NODE_7",
            NODE_8 = "NODE_8",
            NODE_9 = "NODE_9",
            NODE_10 = "NODE_10",
            NODE_11 = "NODE_11",
            NODE_12 = "NODE_12"
    }
    /**
        * Queue type enumeration values.
        */
    export enum QueueTypes {
            ACD = 1,
            SmartQueue = 2
    }
    /**
        * WebRTC Video Settings (aka Constraints)
        * @hidden
        *
        * @deprecated
        */
    export interface VideoSettings {
            /**
                * Optional. The width or width range, in pixels
                */
            width?: number | any;
            /**
                * Optional. The height or height range, in pixels
                */
            height?: number | any;
            /**
                * Optional. The exact aspect ratio (width in pixels divided by height in pixels, represented as a double rounded to the tenth decimal place) or aspect ratio range
                */
            aspectRatio?: number | any;
            /**
                * Optional. The exact frame rate (frames per second) or frame rate range
                */
            frameRate?: number | any;
            /**
                * Optional. This string (or each string, when a list) should be one of the members of VideoFacingModeEnum
                */
            facingMode?: string | any;
            /**
                * Optional. The origin-unique identifier for the source of the MediaStreamTrack
                */
            deviceId?: string;
            /**
                * Optional. The origin-unique group identifier for the source of the MediaStreamTrack. Two devices have the same group identifier if they belong to the same physical device
                */
            groupId?: string;
            /**
                * Optional. Mandatory constraints object
                */
            mandatory?: Object;
            /**
                * Optional. Optional constraints object
                */
            optional?: Object;
    }
    /**
        * Audio recording device info
        */
    export interface AudioSourceInfo {
            /**
                * Device id that can be used to choose audio playback device, see [Client.useAudioOutput]
                */
            id: number | string;
            /**
                * Device name
                */
            name: string;
            group: string;
    }
    /**
        * Video recording device info
        */
    export interface VideoSourceInfo {
            /**
                * Device id that can be used to choose video recording device
                */
            id: number | string;
            /**
                * Device name
                */
            name: string;
            group: string;
    }
    /**
        * Audio playback device info
        * @class
        * @hidden
        * @deprecated
        */
    export interface AudioOutputInfo {
            /**
                * Device id that can be used to choose audio playback device, see [Client.useAudioOutput]</a>
                */
            id: number | string;
            /**
                * Device name, in WebRTC mode populated with real data only when application has been opened via the HTTPS protocol
                */
            name: string;
            /**
                * @hidden
                */
            group: string;
    }
    /**
        * Network information
        * @hidden
        * @deprecated
        */
    export interface NetworkInfo {
            /**
                * Packet loss percentage
                */
            packetLoss: number;
    }
    /**
        * SmartQueue and ACD v1 error codes
        */
    export enum ACDErrorCode {
            /**
                * You cannot get or set an agent status before login.
                */
            NotLoggedIn = 1,
            /**
                * The status is not acceptable for the current agent state.
                */
            IncorrectStatus = 2,
            /**
                * The process of setting the another status is in progress, current call was ignored.
                */
            StatusWillBeIgnored = 3,
            /**
                * The agent status update or get operation failed by timeout.
                */
            FailedByTimeout = 4,
            /**
                * Trying to perform multiple ACD / SmartQueue operations at the same time.
                */
            MultipleOperations = 5,
            /**
                * Using the same credentials in the different browsers or multiple browsers windows.
                */
            MultipleCredentials = 6,
            /**
                * Wrong status name.
                */
            WrongStatus = 7,
            /**
                * Connection to the Voximplant Cloud was closed.
                */
            ConnectionClosed = 8
    }
    /**
        * SmartQueue and ACD v1 statuses enumeration values. Use [Client.setOperatorACDStatus] to set the status.
        *
        * Refer to the [SmartQueue contact center](/docs/guides/contact-center/voice) or the
        * [ACD v1 usage](/docs/guides/smartqueue/acdv1) guides for more detailed information.
        */
    export enum OperatorACDStatuses {
            /**
                * Applies for: ACD v1, SmartQueue (ACD v2), SmartQueue instant messaging.
                *
                * The agent has intentionally declined or ignored an incoming call from a queue within the specified timeout.
                *
                * You may implement your own logic how to return to the Online status.
                */
            Banned,
            /**
                * Applies for: SmartQueue (ACD v2).
                *
                * The agent has an incoming call, which he has not yet answered or declined.
                */
            Dialing,
            /**
                * Applies for: ACD v1, SmartQueue (ACD v2), SmartQueue instant messaging.
                *
                * The agent is offline.
                */
            Offline,
            /**
                * Applies for: ACD v1, SmartQueue (ACD v2), SmartQueue instant messaging.
                *
                * The agent is logged in, but not ready to handle incoming calls yet.
                */
            Online,
            /**
                * Applies for: ACD v1, SmartQueue (ACD v2), SmartQueue instant messaging.
                *
                * Ready to handle incoming calls.
                */
            Ready,
            /**
                * Applies for: ACD v1, SmartQueue (ACD v2), SmartQueue instant messaging.
                *
                * Incoming call is in service.
                */
            InService,
            /**
                * Applies for: ACD v1, SmartQueue (ACD v2).
                *
                * An incoming call has ended and now an agent is processing after service work.
                */
            AfterService,
            /**
                * Applies for: ACD v1.
                *
                * The agent is on a break (e.g. having lunch).
                */
            Timeout,
            /**
                * Applies for: ACD v1, SmartQueue (ACD v2), SmartQueue instant messaging.
                *
                * The agent is in Do Not Disturb state and not ready to handle incoming calls (e.g. working on another call).
                */
            DND,
            /**
                * Applies for: SmartQueue (ACD v2), SmartQueue instant messaging.
                *
                * The custom SmartQueue status. This status works the same way as the DND status. You can give it a custom name.
                *
                * Refer to the [SmartQueue](/docs/guides/contact-center/voice) article to learn more about custom statuses.
                */
            CustomStatus_1,
            /**
                * Applies for: SmartQueue (ACD v2), SmartQueue instant messaging.
                *
                * The custom SmartQueue status. This status works the same way as the DND status. You can give it a custom name.
                *
                * Refer to the [SmartQueue](/docs/guides/contact-center/voice) article to learn more about custom statuses.
                */
            CustomStatus_2,
            /**
                * Applies for: SmartQueue (ACD v2), SmartQueue instant messaging.
                *
                * The custom SmartQueue status. This status works the same way as the DND status. You can give it a custom name.
                *
                * Refer to the [SmartQueue](/docs/guides/contact-center/voice) article to learn more about custom statuses.
                */
            CustomStatus_3,
            /**
                * Applies for: SmartQueue (ACD v2), SmartQueue instant messaging.
                *
                * The custom SmartQueue status. This status works the same way as the DND status. You can give it a custom name.
                *
                * Refer to the [SmartQueue](/docs/guides/contact-center/voice) article to learn more about custom statuses.
                */
            CustomStatus_4,
            /**
                * Applies for: SmartQueue (ACD v2), SmartQueue instant messaging.
                *
                * The custom SmartQueue status. This status works the same way as the DND status. You can give it a custom name.
                *
                * Refer to the [SmartQueue](/docs/guides/contact-center/voice) article to learn more about custom statuses.
                */
            CustomStatus_5,
            /**
                * Applies for: SmartQueue (ACD v2), SmartQueue instant messaging.
                *
                * The custom SmartQueue status. This status works the same way as the DND status. You can give it a custom name.
                *
                * Refer to the [SmartQueue](/docs/guides/contact-center/voice) article to learn more about custom statuses.
                */
            CustomStatus_6,
            /**
                * Applies for: SmartQueue (ACD v2), SmartQueue instant messaging.
                *
                * The custom SmartQueue status. This status works the same way as the DND status. You can give it a custom name.
                *
                * Refer to the [SmartQueue](/docs/guides/contact-center/voice) article to learn more about custom statuses.
                */
            CustomStatus_7,
            /**
                * Applies for: SmartQueue (ACD v2), SmartQueue instant messaging.
                *
                * The custom SmartQueue status. This status works the same way as the DND status. You can give it a custom name.
                *
                * Refer to the [SmartQueue](/docs/guides/contact-center/voice) article to learn more about custom statuses.
                */
            CustomStatus_8,
            /**
                * Applies for: SmartQueue (ACD v2), SmartQueue instant messaging.
                *
                * The custom SmartQueue status. This status works the same way as the DND status. You can give it a custom name.
                *
                * Refer to the [SmartQueue](/docs/guides/contact-center/voice) article to learn more about custom statuses.
                */
            CustomStatus_9,
            /**
                * Applies for: SmartQueue (ACD v2), SmartQueue instant messaging.
                *
                * The custom SmartQueue status. This status works the same way as the DND status. You can give it a custom name.
                *
                * Refer to the [SmartQueue](/docs/guides/contact-center/voice) article to learn more about custom statuses.
                */
            CustomStatus_10
    }
    /**
        * Voximplant login options
        * @class
        */
    export interface LoginOptions {
            /**
                * Optional. Whether to receive calls. If false, Web SDK can be used only for ACD status management
                */
            receiveCalls?: boolean;
            /**
                * Optional. Whether the user presence to be changed automatically while a call is in progress
                * @hidden
                */
            serverPresenceControl?: boolean;
            /**
                * @hidden
                */
            accessToken?: string;
            /**
                * Optional. A unique token for the current device. Use Client.getGUID() and save it at client storage (foe LocalStorage or IndexedDB)
                * @hidden
                */
            deviceToken?: string;
            /**
                * @hidden
                */
            mediaServer?: string;
    }
    export interface CallSettings {
            /**
                * @hidden
                */
            isAudio?: boolean;
            /**
                * The number to call. The international format E.164 is preferable
                */
            number: string;
            /**
                * Optional. Whether to support video for the call
                */
            video?: VideoFlags | boolean;
            /**
                * Optional. Whether auto wire local streams to participants.
                * If false, create empty localStream from audio api to generate sdp
                * @hidden
                */
            wiredLocal?: boolean;
            /**
                * Optional. Whether auto wire remote streams to DOM elements
                * @hidden
                */
            wiredRemote?: boolean;
            /**
                * Optional. Custom parameters (SIP headers) that should be passed with call (INVITE) message. Parameter names should start with "X-" to be processed by application. IMPORTANT: Headers size limit is 200 bytes.
                */
            extraHeaders?: {
                    [id: string]: string;
            };
            /**
                * Optional. Custom string associated with the call session. It can be passed to the cloud to be obtained from the [CallAlerting](/docs/references/voxengine/appevents#callalerting) event or [Call History](/docs/references/httpapi/managing_history#getcallhistory) via the HTTP API. Maximum size is 200 bytes. Use the [Call.sendMessage] method to pass a string over the limit; in order to pass a large data use [media_session_access_url](/docs/references/httpapi/managing_scenarios#startscenarios) on the backend.
                */
            customData?: string;
            /**
                * @deprecated
                * @hidden
                */
            extraParams?: {
                    [id: string]: string;
            };
            /**
                * Optional. Whether to use H264 video codec, if exists
                */
            H264first?: boolean;
            /**
                * Optional. Whether to use VP8 video codec, if exists
                * @hidden
                */
            VP8first?: boolean;
            /**
                * @hidden
                */
            forceActive?: boolean;
            /**
                * @hidden
                */
            isConference?: boolean;
            simulcast?: boolean;
            /**
                * @hidden
                */
            simulcastProfileName?: 'general' | 'b24';
    }
    /**
        * @hidden
        */
    export interface InnerCallSettings extends CallSettings {
            id: string;
            displayName: string;
            active: boolean;
            state: CallState;
            mode: CallMode;
            usedSinkId: number | string;
            videoDirections: VideoFlags;
            hasEarlyMedia: boolean;
            audioDirections: AudioFlags;
            incoming: boolean;
            simulcast: boolean;
            simulcastProfileName?: 'general' | 'b24';
            mixedAudioTrackID?: string;
            /**
                * Optional. Whether the P2P call is direct, i.e. initiated by one of VoxEngine direct call methods, e.g. `callUserDirect`
                */
            isDirect?: boolean;
    }
    /**
        * Call disconnecting flags
        */
    export interface DisconnectingFlags {
            /**
                * Whether the call is answered elsewhere
                */
            answeredElsewhere: boolean;
    }
    export interface LoginTokens {
            /**
                * You can use this token for login before accessExpire. Access token TTL is 48 hours. The actual value in ms is returned in the response payload.
                */
            accessToken: string;
            /**
                * Refresh token. You can use it 1 time before refreshExpire. Refresh token TTL is 30 days. The actual value in ms is returned in the response payload.
                */
            refreshToken: string;
            /**
                * Seconds before the access token expiration (in UNIX timestamp format)
                */
            accessExpire: number;
            /**
                * Seconds before the refresh token expiration (in UNIX timestamp format)
                */
            refreshExpire: number;
    }
    /**
        * Authentication result code
        */
    export enum AuthResultCode {
            /**
                * One-time key is received, code 302.
                */
            OneTimeKeyReceived = 302,
            /**
                * Password is incorrect, code 401.
                */
            InvalidPassword = 401,
            /**
                * Monthly active users limit is reached, code 402.
                */
            MAUAccessDenied = 402,
            /**
                * Account is frozen, code 403.
                */
            AccountFrozen = 403,
            /**
                * Username does not exist, code 404.
                */
            InvalidUsername = 404,
            /**
                * Connection has been closed, code 409.
                */
            ConnectionClosed = 409,
            /**
                * Invalid client state, i.e. already authorized, code 491.
                */
            InvalidState = 491,
            /**
                * Internal error, code 500.
                */
            InternalError = 500,
            /**
                * Auth token has expired, code 701.
                */
            TokenExpired = 701
    }
    /**
        * Video direction settings for <a href="../classes/client.html#call">Client.call()</a> and <a href="../classes/call.html#answer">Call.answer()</a>
        */
    export interface VideoFlags {
            /**
                * whether to send video to the remote participant. The default value is false.
                */
            sendVideo: boolean;
            /**
                * Whether to receive video from a remote participant. The default value is false. If false and an incoming call sends a video stream, the call provides only an audio stream.
                */
            receiveVideo: boolean;
    }
    /**
        * @hidden
        */
    export interface AudioFlags {
            sendAudio: boolean;
    }
    /**
        * @hidden
        */
    export interface reinviteDescription {
            tracks: {
                    [id: string]: TrackType;
            };
            mids: {
                    [id: string]: TrackType;
            };
            restartTransport?: boolean;
            iceRestart?: boolean;
    }
    /**
        * Structure for outer logging
        */
    export interface LogRecord {
            /**
                * The text that is displayed in the browser console.
                */
            formattedText: string;
            /**
                * Name of the module that creates a record.
                */
            category: LogCategory;
            /**
                * Record label
                */
            label: string;
            /**
                * Possible LogLevel values:
                *
                * |Value|Meaning |
                * |-----|--------|
                * |1    |ERROR   |
                * |2    |WARNING |
                * |3    |INFO    |
                * |4    |TRACE   |
                *
                */
            level: LogLevel;
            /**
                * Record message
                */
            message: string;
    }
    export enum MediaRendererKind {
            Audio = "audio",
            Video = "video",
            Sharing = "sharing"
    }
}

declare module 'voximplant-websdk/Logger' {
    /**
        * @hidden
        */
    export enum LogLevel {
            NONE = 0,
            ERROR = 1,
            WARNING = 2,
            INFO = 3,
            TRACE = 4
    }
    /**
        * @hidden
        */
    export enum LogCategory {
            SIGNALING = 0,
            RTC = 1,
            USERMEDIA = 2,
            CALL = 3,
            CALLEXP2P = 4,
            CALLEXSERVER = 5,
            CALLMANAGER = 6,
            CLIENT = 7,
            AUTHENTICATOR = 8,
            PCFACTORY = 9,
            UTILS = 10,
            ORTC = 11,
            MESSAGING = 12,
            REINVITEQ = 13,
            HARDWARE = 14,
            ENDPOINT = 15,
            EVENTTARGET = 16,
            VSM = 17
    }
    /**
        * The client states
        */
    export enum ClientState {
            /**
                * The client is currently disconnected
                */
            DISCONNECTED,
            /**
                * The client is currently connecting
                */
            CONNECTING,
            /**
                * The client is currently connected
                */
            CONNECTED,
            /**
                * The client is currently reconnecting
                */
            RECONNECTING,
            /**
                * The client is currently logging in
                */
            LOGGING_IN,
            /**
                * The client is currently logged in
                */
            LOGGED_IN
    }
    /**
        * Common logger
        * @hidden
        */
    export class Logger {
            constructor(category: LogCategory, label: string, provider: LogManager);
            log(level: LogLevel, message: string): void;
            error(message: string): void;
            warning(message: string): void;
            info(message: string): void;
            trace(message: string): void;
    }
    /**
        * @hidden
        */
    export class LogManager {
            static logTick: number;
            static traceTick: number;
            get shadowLogging(): boolean;
            set shadowLogging(flag: boolean);
            static get(): LogManager;
            /**
                * Decorator for tracing
                */
            static d_trace(category: LogCategory): (target: object, propertyKey: string, descriptor: TypedPropertyDescriptor<(...args: any[]) => any>) => TypedPropertyDescriptor<(...args: any[]) => any>;
            getSLog(): Array<string>;
            clearSilentLog(): void;
            setLoggerCallback(callback: {
                    (record: {
                            formattedText: string;
                            category: LogCategory;
                            label: string;
                            level: LogLevel;
                            message: string;
                    }): void;
            }): void;
            setPrettyPrint(state: boolean): void;
            setLogLevel(category: LogCategory, level: LogLevel): void;
            writeMessage(category: LogCategory, label: string, level: LogLevel, message: string | object): void;
            createLogger(category: LogCategory, label: string): Logger;
            /**
                * @hidden
                * @return {string}
                * @private
                */
            _traceName(): string;
    }
}

declare module 'voximplant-websdk/Hardware/index' {
    import * as Implement from 'voximplant-websdk/Hardware/src';
    export module Hardware {
            /**
                * Events that are triggered when hardware device is added/removed/updated.
                * @event
                */
            enum HardwareEvents {
                    /**
                        * Triggered when an external device is connected or disconnected or when a default device changes.
                        *
                        * Devices that can trigger the event: microphones, video camera and sound output. Based on browser's
                        * [devicechange](https://caniuse.com/mdn-api_mediadevices_devicechange_event) event.
                        *
                        * @cast EventHandlers.DevicesUpdated
                        */
                    DevicesUpdated,
                    /**
                        * Triggered when a new audio or video renderer added, such as local video or screen sharing.
                        *
                        * @cast EventHandlers.MediaRendererAdded
                        */
                    MediaRendererAdded,
                    /**
                        * Triggered when the local video or audio streaming is updated. E.g., when the local video or screen sharing is stopped.
                        * @cast EventHandlers.MediaRendererUpdated
                        */
                    MediaRendererUpdated,
                    /**
                        * Triggered when the local video or audio streaming is stopped. E.g., when the local video or screen sharing is stopped.
                        * @cast EventHandlers.MediaRendererRemoved
                        */
                    MediaRendererRemoved,
                    /**
                        * Triggered before the local video or audio streaming is stopped. E.g., before local video or screen sharing is stopped.
                        * @cast EventHandlers.BeforeMediaRendererRemoved
                        */
                    BeforeMediaRendererRemoved
            }
            /**
                * Enum that represents video quality.
                */
            enum VideoQuality {
                    /**
                        * Set better video quality for the current web camera.
                        * This option uses the last value from the [CameraManager.testResolutions] function result,
                        * or the data set to the [CameraManager.loadResolutionTestResult].
                        * If there is no result for a target web camera, use 1280x720 resolution
                        */
                    VIDEO_QUALITY_HIGH,
                    /**
                        * Set medium video quality for the current web camera.
                        * This option uses the last value from the [CameraManager.testResolutions] function result,
                        * or the data set to the [CameraManager.loadResolutionTestResult].
                        * If there is no result for a target web camera, use 640x480 resolution
                        */
                    VIDEO_QUALITY_LOW,
                    /**
                        * Set lower video quality for the current web camera.
                        * This option uses the last value from the [CameraManager.testResolutions] function result,
                        * or the data set to the [CameraManager.loadResolutionTestResult].
                        * If there is no result for a target web camera, use 320x240 resolution
                        */
                    VIDEO_QUALITY_MEDIUM,
                    /**
                        * 160x120 resolution
                        */
                    VIDEO_SIZE_QQVGA,
                    /**
                        * 176x144 resolution
                        */
                    VIDEO_SIZE_QCIF,
                    /**
                        * 320x240 resolution
                        */
                    VIDEO_SIZE_QVGA,
                    /**
                        * 352x288 resolution
                        */
                    VIDEO_SIZE_CIF,
                    /**
                        * 640x360 resolution
                        */
                    VIDEO_SIZE_nHD,
                    /**
                        * 640x480 resolution
                        */
                    VIDEO_SIZE_VGA,
                    /**
                        * 800x600 resolution
                        */
                    VIDEO_SIZE_SVGA,
                    /**
                        * 1280x720 resolution
                        */
                    VIDEO_SIZE_HD,
                    /**
                        * 1600x1200 resolution
                        */
                    VIDEO_SIZE_UXGA,
                    /**
                        * 1920x1080 resolution
                        */
                    VIDEO_SIZE_FHD,
                    /**
                        * 3840x2160 resolution
                        */
                    VIDEO_SIZE_UHD
            }
            /**
                * Interface that may be used to manage audio devices, i.e. see current active device, select another active device and get the list of available devices.
                */
            class AudioDeviceManager extends Implement.AudioDeviceManager {
            }
            /**
                * Audio constraints. Audio device is chosen according to these settings.</br>
                * Settings are specified via
                * [AudioDeviceManager.setDefaultAudioSettings]
                *   and
                *   [AudioDeviceManager.setCallAudioSettings].
                */
            interface AudioParams extends Implement.AudioParams {
            }
            /**
                * Interface that may be used to manage cameras on Android device.
                */
            class CameraManager extends Implement.CameraManager {
            }
            /**
                * Camera constraints. Hardware camera is chosen according to these settings.</br>
                * Settings are specified via
                * [CameraManager.setDefaultVideoSettings]
                *   and [CameraManager.setCallVideoSettings].
                */
            interface CameraParams extends Implement.CameraParams {
            }
            /**
                * @hidden
                */
            interface SharingStream extends Implement.SharingStream {
            }
            /**
                * Interface for extended management of local audio/video streams.
                */
            class StreamManager extends Implement.StreamManager {
            }
    }
    export default Hardware;
}

declare module 'voximplant-websdk/Media/MediaRenderDisablingReason' {
    /**
         * Enum that represents the reason why video receive on a remote video stream is stopped.
     */
    export enum MediaRenderDisablingReason {
            /**
                * Indicates that video receive on a remote video stream is stopped by the Voximplant Cloud due to a network issue on the device.
             */
            Automatic = "automatic",
            /**
                * Indicates that video receive on a remote video stream is stopped by the client via [MediaRenderer.disable()](/docs/references/websdk/voximplant/mediarenderer#disable)
             */
            Manual = "manual"
    }
}

declare module 'voximplant-websdk/Call/AbstractCall' {
    import { EventListenerOption, EventTarget } from 'voximplant-websdk/EventTarget';
    import { CallEvents } from 'voximplant-websdk/Call/CallEvents';
    import { SimpleCall } from 'voximplant-websdk/Call/SimpleCall';
    import { DisconnectingFlags, InnerCallSettings } from 'voximplant-websdk/Structures';
    import { Logger } from 'voximplant-websdk/Logger';
    import { Endpoint } from 'voximplant-websdk/Call/EndPoints/Endpoint';
    import { ViewerCall } from 'voximplant-websdk/Call/ViewerCall';
    import { Call } from 'voximplant-websdk/Call/Call';
    import { SharingCall } from 'voximplant-websdk/Call/SharingCall';
    /**
        * The call states
        */
    export enum CallState {
            ALERTING,
            PROGRESSING,
            CONNECTED,
            UPDATING,
            STOPPING,
            ENDED
    }
    /**
        * @hidden
        */
    export enum CallMode {
            P2P = 0,
            SERVER = 1
    }
    /**
        * @hidden
        */
    export abstract class AbstractCall extends EventTarget<CallEvents> implements SimpleCall {
            /**
                * @hidden
                */
            signalingConnected: boolean;
            /**
                * @hidden
                */
            settings: InnerCallSettings;
            /**
                * @hidden
                */
            protected logger: Logger;
            /**
                * @hidden
                */
            protected remoteMuteState: boolean;
            /**
                * @hidden
                */
            protected startTime: number;
            /**
                * @hidden
                */
            connectedPromise: Promise<void>;
            protected constructor(id: string);
            abstract getEndpoints(): Endpoint[];
            id(): string;
            number(): string;
            displayName(): string;
            getCallDuration(): number;
            /**
                * Returns headers
                * @returns {Object}
                */
            headers(): {
                    [id: string]: string;
            };
            state(): CallState;
            /**
                * @hidden
                */
            checkCallMode(mode: CallMode): boolean;
            hangup(extraHeaders?: {
                    [id: string]: string;
            }): void;
            /**
                * Mutes the sound from all participants
                */
            mutePlayback(): void;
            /**
                * Unmutes the sound from all participants
                */
            unmutePlayback(): void;
            /**
                * @hidden
                */
            restoreRMute(): void;
            /**
                * Send Info (SIP INFO) message inside the call
                *
                * You can get this message via the Voxengine [CallEvents.InfoReceived] event in our cloud.
                *
                * You can get this message in Web SDK on other side via the [CallEvents.InfoReceived] event; see the similar events for the <a href="/docs/references/iossdk/call/vicalldelegate#calldidreceiveinfotypeheaders">iOS</a> and <a href="/docs/references/androidsdk/call/icalllistener#onsipinforeceived">Android</a> SDKs.
                * @param {String} mimeType MIME type of the message, e.g. "text/plain", "multipart/mixed" etc.
                * @param {String} body Message content
                * @param {[id:string]:string} extraHeaders Optional headers to be passed with the message
                */
            sendInfo(mimeType: string, body: string, extraHeaders?: {
                    [id: string]: string;
            }): void;
            sendMessage(msg: string): void;
            /**
                * Register a handler for the specified event. One event can have more than one handler; handlers are executed in order of registration.
                * Use the [removeEventListener] method to delete a handler.
                * @param {Function} event Event name (i.e. [CallEvents.Connected]). See [CallEvents].
                * @param {Function} handler Handler function. A single parameter is passed - object with event information
                * @deprecated
                * @hidden
                */
            addEventListener(event: CallEvents, handler: (ev: any) => void): void;
            /**
                * Register a handler for the specified event. The method is a shorter equivalent for *addEventListener*. One event can have more than one handler; handlers are executed in order of registration.
                * Use the [Call.off] method to delete a handler.
                * @param {string} event Event name (i.e. [CallEvents.Connected]. See [CallEvents].
                * @param {Function} handler Handler function. A single parameter is passed - object with event information
                */
            on(event: CallEvents, handler: (ev: any) => void, options?: EventListenerOption): void;
            /**
                * Remove handler for specified event
                * @param {Function} event Event name (i.e. [CallEvents.Connected]). See [CallEvents].
                * @param {Function} handler Handler function, if not specified all event handlers for the specified event are removed
                * @deprecated
                * @hidden
                */
            removeEventListener(event: CallEvents, handler?: (ev: any) => void): void;
            /**
                * Remove a handler for the specified event. The method is a shorter equivalent for *removeEventListener*. If a number of events has the same function as a handler, the method can be called multiple times with the same handler argument.
                * @param {string} event Event name (i.e. [CallEvents.Connected]). See [CallEvents].
                * @param {Function} handler Handler function, if not specified all event handlers for the specified event are removed
                * @function
                */
            off(event: CallEvents, handler?: (ev: any) => void): void;
            /**
                * @hidden
                */
            dispatchEvent(e: any): void;
            /**
                * @hidden
                */
            abstract onInfo(call: ViewerCall | Call | SharingCall, type: string, subType: string, body: string, headers: {
                    [id: string]: string;
            }): boolean;
            /**
                * @hidden
                */
            abstract onDisconnected(headers: {
                    [id: string]: string;
            }, params: DisconnectingFlags): Promise<boolean>;
            /**
                * @hidden
                * @param headers
                * @param sdp
                * @returns {boolean}
                */
            onConnected(headers: {
                    [id: string]: string;
            }, sdp: string): boolean | void;
            /**
                * @hidden
                * @param code
                * @param reason
                * @param headers
                * @returns {boolean}
                */
            onFailed(code: number, reason: string, headers: {
                    [id: string]: string;
            }): boolean;
            /**
                * @hidden
                * @param newState
                * @private
                */
            protected _setState(newState: CallState): CallState;
            /**
                *
                * @param validState
                * @param functionName
                * @returns {boolean}
                * @hidden
                */
            protected checkState(validState: CallState | CallState[], functionName: string): boolean;
    }
}

declare module 'voximplant-websdk/Call/Call' {
    import { EventHandlers } from 'voximplant-websdk/EventHandlers';
    import { PeerConnection } from 'voximplant-websdk/PeerConnection/PeerConnection';
    import { CodecSorterUserCodecList } from 'voximplant-websdk/PeerConnection/SDP/Interfaces';
    import { CallSettings, DisconnectingFlags, VideoFlags, VideoSettings } from 'voximplant-websdk/Structures';
    import { AbstractCall, CallState } from 'voximplant-websdk/Call/AbstractCall';
    import { Endpoint } from 'voximplant-websdk/Call/EndPoints/Endpoint';
    /**
        * The Call class represents a single call or conference, incoming or outgoing.
        *
        * For an incoming call/conference, get the call instance from the [IncomingCall](/docs/references/websdk/voximplant/events#incomingcall) event.
        * To create an outgoing call, use the [Client.call](/docs/references/websdk/voximplant/client#call) API.
        * To create an outgoing conference, use the [Client.callConference](/docs/references/websdk/voximplant/client#callconference) API.
        */
    export abstract class Call extends AbstractCall {
            /**
                * @hidden
                */
            protected _peerConnection: PeerConnection;
            /**
                * Callback for a manual rearrangement or setup compatible codec list. If an unknown/unsupported codec is set, the parameter is ignored
                * @param CodecSorterUserCodecList
                * @returns {Promise<CodecSorterUserCodecList>}
                */
            rearangeCodecs: (codecList: CodecSorterUserCodecList, incoming?: boolean) => Promise<CodecSorterUserCodecList>;
            /**
                * @hidden
                */
            constructor(id: string, dn: string, incoming: boolean, settings: CallSettings);
            /**
                * @hidden
                */
            protected _promise: Promise<Object>;
            /**
                * @hidden
                * @returns {Promise<Object>}
                */
            get promise(): Promise<Object>;
            /**
                * @hidden
                * @returns {PeerConnection}
                */
            get peerConnection(): PeerConnection;
            /**
                * @hidden
                * @param peerConnection
                */
            set peerConnection(peerConnection: PeerConnection);
            /**
                * @hidden
                * @returns {CallState}
                */
            get stateValue(): CallState;
            /**
                * Returns 'true' if a call is active, otherwise returns 'false'. A single call (either incoming or outgoing) is active by default, all other calls are inactive and should be activated via the <a href="#setactive">setActive</a> method. Only the active call sends and receives an audio/video stream.
                */
            active(): boolean;
            /**
                * @hidden
                * @param newState
                * @private
                */
            protected _setActive(newState: boolean): boolean;
            /**
                * Answers the incoming call. There are two methods for an [IncomingCall]: [Call.answer] and [Call.decline]. Voice can be sended only after the [Call.answer] method call.
                * @param {String} customData Set custom string associated with call session. It can be later obtained from [Call History](/docs/references/httpapi/history#getcallhistory) via the HTTP API, see the custom_data field in [result](/docs/references/httpapi/structure/callsessioninfotype). Custom data can be retrieved on the part of Voxengine via the [customData](/docs/references/voxengine/voxengine/customdata) method. Maximum size is 200 bytes.
                * @param {Object} extraHeaders Optional custom parameters (SIP headers) that are sent to another participant after accepting an incoming call. Header names have to begin with the 'X-' prefix. The "X-" headers could be handled only by SIP phones/devices.
                * @param {VideoFlags} useVideo - [A set of flags](/docs/references/websdk/voximplant/videoflags) defining if sending and receiving video is allowed.
                * @param {Boolean} H264first Use H264 video codec, if exist
                */
            answer(customData?: string, extraHeaders?: {
                    [id: string]: string;
            }, useVideo?: VideoFlags, H264first?: boolean): void;
            /**
                * Rejects the incoming call on all devices, where the current user logged in.
                * @param {Object} extraHeaders Optional custom parameters (SIP headers) that should be sent after rejecting incoming call. Parameter names should start with "X-" to be processed by application
                */
            decline(extraHeaders?: {
                    [id: string]: string;
            }): void;
            /**
                * Rejects the incoming call on the side of Web SDK.
                *
                * If a call is initiated from a PSTN, the network receives the "reject" command; in case of a call from another SDK client, it receives the [CallEvents.Failed] event.
                *
                *
                * @param {Object} extraHeaders Optional custom parameters (SIP headers) that should be sent after rejecting incoming call. Parameter names should start with "X-" to be processed by application
                */
            reject(extraHeaders?: {
                    [id: string]: string;
            }): void;
            hangup(extraHeaders?: {
                    [p: string]: string;
            }): void;
            /**
                * Sends a tone (DTMF). It triggers the <a href="/docs/references/voxengine/callevents#tonereceived">CallEvents.ToneReceived</a> event in our cloud.
                * @param {String} key Send tone according to pressed key: 0-9 , * , #
                */
            sendTone(key: string): void;
            /**
                * Returns the current state of the microphone in this call.
                * @returns {boolean}
                */
            isMicrophoneMuted(): boolean;
            muteMicrophone(): void;
            unmuteMicrophone(): void;
            /**
                * @deprecated
                * @hidden
                */
            showRemoteVideo(flag?: boolean): void;
            /**
                * @deprecated
                * @hidden
                */
            setRemoteVideoPosition(x: number, y: number): void;
            /**
                * @deprecated
                * @hidden
                */
            setRemoteVideoSize(width: number, height: number): void;
            /**
                * Sets video settings
                * @param {VoxImplant.VideoSettings|VoxImplant.FlashVideoSettings} settings Video settings for current call
                * @param {Function} [successCallback] Called in WebRTC mode if video settings are applied successfully
                * @param {Function} [failedCallback] Called in WebRTC mode if video settings cannot be applied
                * @deprecated
                * @hidden
                */
            setVideoSettings(settings: VideoSettings, successCallback?: Function, failedCallback?: Function): void;
            /**
                * Returns HTML video element's id for the call
                * @deprecated
                * @hidden
                */
            getVideoElementId(): string;
            /**
                * @hidden
                * @param headers
                * @param params
                * @returns {boolean}
                */
            onDisconnected(headers: {
                    [id: string]: string;
            }, params: DisconnectingFlags): Promise<boolean>;
            /**
                * @hidden
                * @returns {boolean}
                */
            onStopRinging(): boolean;
            /**
                * @hidden
                * @returns {boolean}
                */
            onRingOut(): boolean;
            /**
                * @hidden
                * @returns {boolean}
                */
            onTransferComplete(): boolean;
            /**
                * @hidden
                * @returns {boolean}
                */
            onTransferFailed(): boolean;
            /**
                * @hidden
                * @param call
                * @param type
                * @param subType
                * @param body
                * @param headers
                * @returns {boolean}
                */
            onInfo(call: Call, type: string, subType: string, body: string, headers: {
                    [id: string]: string;
            }): boolean;
            /**
                *
                * Makes a call active, i.e. change the [active] flag to 'true'.
                * A single call (either incoming or outgoing) is active by default, all other calls are inactive and should be activated.
                * @param {boolean} flag
                * @returns {Promise<EventHandlers.Updated>}
                */
            setActive(flag: boolean): Promise<EventHandlers.Updated>;
            /**
                * @hidden
                */
            canStartSendingCandidates(): void;
            sendVideo(flag: boolean): Promise<EventHandlers.Updated>;
            /**
                * @hidden
                * @param audio
                * @param video
                */
            sendMedia(audio: boolean, video: boolean): Promise<EventHandlers.Updated>;
            /**
                * Starts screen sharing and replaces local and sent video. Since the 4.6.0 version, the `showLocalView` and `replaceVideo` arguments are deprecated.
                * @function
                * @returns Promise<EventHandlers.Updated>
                */
            shareScreen(showLocalView?: boolean, replaceVideo?: boolean): Promise<EventHandlers.Updated>;
            /**
                * Stops screen sharing started via the `shareScreen()` method. Since the 4.6.0 version, the `BeforeMediaRendererRemoved` and `MediaRendererRemoved` events are deprecated for the local video. Use `MediaRendererUpdated` instead.
                * @function
                * @returns Promise<EventHandlers.SharingStopped>
                */
            stopSharingScreen(): Promise<EventHandlers.SharingStopped>;
            /**
                * @hidden
                * @returns {Promise<MediaStream>|Promise}
                */
            getRemoteAudioStreams(): Promise<MediaStream>;
            /**
                * @hidden
                * @deprecated
                * @returns {Promise<MediaStream>|Promise}
                */
            getRemoteVideoStreams(): Promise<MediaStream>;
            /**
                * Uses a specified audio output , use [audioOutputs] to get the list of available audio output
                * @param {String} id Id of the audio source
                * @hidden
                * @deprecated
                */
            useAudioOutput(id: string): Promise<void>;
            /**
                * Returns HTML audio element's id for the audio call
                * @returns string
                * @deprecated
                * @hidden
                */
            getAudioElementId(): string;
            /**
                * @hidden
                * @param headers
                * @param sdp
                */
            runIncomingReInvite(headers: {
                    [id: string]: string;
            }, sdp: string): void;
            /**
                * @hidden
                * @param state
                */
            setActiveForce(state: any): void;
            /**
                * Gets all current [Endpoint]s in the call.
                * @returns {Endpoint[]}
                */
            getEndpoints(): Endpoint[];
            /**
                * @hidden
                * @param scale
                */
            scaleVideoResolutionDownBy(scale: any): Promise<any[]>;
            /**
                * @hidden
                * @return {string}
                * @private
                */
            _traceName(): string;
    }
}

declare module 'voximplant-websdk/Signaling/VoxSignalingHandler' {
    /**
      * Handler of signaling connection events
      * @hidden
      */
    export interface VoxSignalingHandler {
        onSignalingConnected(): any;
        onSignalingClosed(): any;
        onSignalingConnectionFailed(errorMessage: string): any;
        onMediaConnectionFailed(): any;
    }
}

declare module 'voximplant-websdk/EventTarget' {
    /**
        * @hidden
        */
    type EventNamespace = 'user' | 'system' | 'default';
    /**
        * @hidden
        */
    interface EventListenerInstance {
            listener: Function;
            options?: EventListenerOption;
            _triggered: boolean;
            _namespace: EventNamespace;
    }
    /**
        * @hidden
        */
    export interface EventListenerOption {
            once?: boolean;
            capture?: boolean;
    }
    /**
        * @hidden
        */
    export abstract class EventTarget<EventType> {
            /**
                * @hidden
                * @type {{}}
                */
            eventListeners: {
                    [event: string]: EventListenerInstance[];
            };
            /**
                *
                * @param event
                * @param handler
                * @param options
                * @hidden
                */
            sysOn(event: EventType, handler: (ev: any) => void, options?: EventListenerOption): void;
            /**
                *
                * @param event
                * @param handler
                * @hidden
                */
            sysOff(event: EventType, handler?: (ev: any) => void): void;
            on(event: EventType, handler: (ev: any) => void, options?: EventListenerOption): void;
            off(event: EventType, handler?: (ev: any) => void): void;
            /**
                * @hidden
                * @param e
                */
            dispatchEvent(e: any): void;
            /**
                * @hidden
                * @deprecated
                * @param {EventType} event
                * @param {Function} handler
                */
            removeEventListener(event: EventType, handler?: (ev: any) => void): void;
            /**
                * @hidden
                * @deprecated
                * @param {EventType} event
                * @param {EventListenerObject} handler
                * @param options
                */
            addEventListener(event: EventType, handler: (ev: any) => void, options?: EventListenerOption): void;
            /**
                * @hidden
                * @param {EventType} event
                * @param {EventListenerObject} handler
                */
            addDefaultEventListener(event: EventType, handler?: (ev: any) => void): void;
            /**
                * @hidden
                * @param {EventType} event
                */
            removeDefaultEventListener(event: EventType): void;
            /**
                * @hidden
                * @return {string}
                * @private
                */
            _traceName(): string;
    }
    export {};
}

declare module 'voximplant-websdk/EventHandlers' {
    import { ACDErrorCode, AudioSourceInfo, AuthResultCode, DisconnectingFlags, LoginTokens, MediaRendererKind, NetworkInfo, OperatorACDStatuses, VideoSourceInfo } from 'voximplant-websdk/Structures';
    import { Call } from 'voximplant-websdk/Call/Call';
    import { Endpoint } from 'voximplant-websdk/Call/EndPoints/Endpoint';
    import { MediaRenderer } from 'voximplant-websdk/Media/MediaRenderer';
    import { TrackType } from 'voximplant-websdk/Types';
    import { CallState } from 'voximplant-websdk/Call/AbstractCall';
    import { StatsReport } from 'voximplant-websdk/Stats/v5/StatsReport';
    import { CallEvents } from 'voximplant-websdk/Call/CallEvents';
    import { MediaRenderDisablingReason } from 'voximplant-websdk/Media/MediaRenderDisablingReason';
    import Hardware from 'voximplant-websdk/Hardware';
    export namespace EventHandlers {
            interface AuthResult extends AuthTokenResult {
                    /**
                        * Optional. Authorized user's display name
                        */
                    displayName?: string;
                    /**
                        * Optional. Use to calculate the hash parameter for [Client.loginWithOneTimeKey] method.
                        * Triggers the AuthResult event with the key after the [Client.requestOneTimeLoginKey] method is called.
                        */
                    key?: string;
            }
            interface AuthTokenResult {
                    /**
                        * @hidden
                        */
                    name: string;
                    /**
                        * Optional. Authentication result code.
                        */
                    code?: AuthResultCode;
                    /**
                        * Whether the refresh is successful
                        */
                    result: boolean;
                    /**
                        * Optional. New tokens structure
                        */
                    tokens?: LoginTokens;
            }
            interface ConnectionFailed {
                    /**
                        * Failure reason description
                        */
                    message: string;
            }
            interface IncomingCall {
                    /**
                        * Incoming call instance.
                        * See the [Call] interface for details
                        */
                    call: Call;
                    /**
                        * Optional. SIP headers received with the message
                        */
                    headers?: Object;
                    /**
                        * Optional. Whether the caller initiated a video call
                        */
                    video?: boolean;
            }
            interface MicAccessResult {
                    /**
                        * Whether access is granted
                        */
                    result: boolean;
                    /**
                        * MediaStream object
                        */
                    stream: MediaStream;
                    fallback?: boolean;
            }
            interface NetStatsReceived {
                    /**
                        *    Network info object
                        */
                    stats: NetworkInfo;
            }
            interface SDKReady {
                    /**
                        *    SDK version
                        */
                    version: string;
            }
            interface CallEvent {
                    /**
                        *  Call that triggered the event
                        */
                    call: Call;
                    /**
                        * @hidden
                        */
                    name: CallEvents;
            }
            interface CallEventWithHeaders extends CallEvent {
                    /**
                        * Optional. SIP headers are received with the message
                        */
                    headers?: Object;
            }
            interface Disconnected extends CallEventWithHeaders {
                    /**
                        * Optional. Disconnecting flags
                        */
                    params?: DisconnectingFlags;
            }
            interface Failed extends CallEventWithHeaders {
                    /**
                        * Call status code (i.e. 486)
                        *
                        * Most frequent status codes:
                        *
                        * |Code|Description                       |
                        * |----|----------------------------------|
                        * |486 |Destination number is busy        |
                        * |487 |Request terminated                |
                        * |603 |Call has been rejected            |
                        * |404 |Invalid number                    |
                        * |480 |Destination number is unavailable |
                        * |402 |Insufficient funds                |
                        */
                    code: number;
                    /**
                        *  Status message of a call failure (i.e. Busy Here)
                        */
                    reason: string;
            }
            interface InfoReceived extends CallEventWithHeaders {
                    /**
                        *  Content of the message
                        */
                    body: string;
                    /**
                        *  MIME type of INFO message
                        */
                    mimeType: string;
            }
            interface MessageReceived extends CallEvent {
                    /**
                        *  Content of the message
                        */
                    text: string;
            }
            interface MediaElementCreated extends CallEvent {
                    /**
                        *  Type of media
                        */
                    type: string;
                    /**
                        * Renderer element
                        */
                    element: HTMLMediaElement;
            }
            interface Updated extends CallEvent {
                    /**
                        * Whether the update is successful.
                        */
                    result: boolean;
                    /**
                        * Optional. Reason of unsuccessful updating.
                        */
                    reason?: string;
            }
            interface SharingStopped extends CallEvent {
                    /**
                        * Whether the update is successful.
                        */
                    result: boolean;
            }
            /**
                * @hidden
                */
            interface UpdateFailed extends CallEvent {
                    /**
                        *  Most frequent status codes:
                        *
                        * |Code|Description                                |
                        * |----|-------------------------------------------|
                        * |10  |Timeout                                    |
                        * |11  |Trying to hold call in wrong state         |
                        * |12  |Trying change call in state UPDATING       |
                        * |13  |Media access denied                      |
                        * |14  |Trying change call state to the same state |
                        * |20  |Server reject                              |
                        */
                    code: number;
            }
            /**
                * @hidden
                */
            interface LocalVideoStreamAdded extends MediaElementCreated {
                    videoStream: MediaStream;
            }
            interface SIPRegistrationResult {
                    /**
                        * @hidden
                        */
                    name: string;
                    /**
                        * SIP registration id
                        */
                    id: string;
                    /**
                        * SIP URI
                        */
                    sipuri: string;
                    /**
                        * Status code, in case of an error
                        */
                    status?: number;
                    /**
                        * Optional. Reason, in case of an error
                        */
                    reason?: string;
            }
            interface EndpointHandler {
                    /**
                        * @hidden
                        */
                    name: string;
                    call: Call;
                    endpoint: Endpoint;
            }
            interface EndpointMediaHandler extends EndpointHandler {
                    mediaRenderer: MediaRenderer;
            }
            interface ACDStatusEvent {
                    id: string;
                    status: OperatorACDStatuses;
                    description?: string;
            }
            interface ACDErrorEvent {
                    message: string;
                    code: ACDErrorCode;
                    action: 'getStatus' | 'setStatus';
                    status?: OperatorACDStatuses;
            }
            interface SQErrorEvent {
                    message: string;
                    code: ACDErrorCode;
                    action: 'getStatus' | 'setStatus';
                    status?: OperatorACDStatuses;
            }
            interface ActiveUpdated extends CallEvent {
                    /**
                        * Old call's activity status
                        */
                    old: boolean;
                    /**
                        * Current call's activity status
                        */
                    new: boolean;
            }
            interface StateUpdated extends CallEvent {
                    /**
                        * Old call's state
                        */
                    old: CallState;
                    /**
                        * Current call's state
                        */
                    new: CallState;
            }
            /**
                * Reported in a handler function for [CallEvents.QualityIssueCodecMismatch].
                * The issue level is [QualityIssueLevel.Critical] if a stream is not sent or [QualityIssueLevel.Major] in case of codec mismatch.
                * Possible reasons:
                * - The device does not support a selected codec. For example, if H264first is specified and the device does not support this hardware codec, the issue is triggered.
                * - The stream is not being sent for some reasons. In this case sendCodec is undefined.
                * - Different codecs are specified in the call endpoints.
                *
                * Only in Chrome
                * @hidden
                */
            interface CodecMismatchIssue extends CallEvent {
                    /**
                        * Issue level.
                        */
                    level: number;
                    /**
                        * Type of stream.
                        */
                    kind: TrackType;
                    /**
                        * Codec that is currently used or undefined if a stream is not sent.
                        */
                    sendCodec: string | undefined;
            }
            /**
                * Reported in a handler function for [CallEvents.QualityIssueHighMediaLatency].
                * Latency is calculated based on rtt (round trip time) and jitter buffer delay. Latency refers to the time it takes a voice/video packet to reach its destination plus the time it waits in a jitter buffer. Sufficient latency causes call participants to speak over the top of each other.
                * The issue level may vary during the call.
                * Possible reasons:
                * - Network congestion/delays.
                * - Lack of bandwidth.
                *
                * Only in Chrome
                * @hidden
                */
            interface HighMediaLatencyIssue extends CallEvent {
                    /**
                        * Issue level.
                        */
                    level: number;
                    /**
                        * Average latency for the last 2.5 seconds measured in milliseconds.
                        */
                    latency: number;
            }
            /**
                * Reported in a handler function for [CallEvents.QualityIssueICEDisconnected].
                * The issue level is always [QualityIssueLevel.Critical] as there is no media in the call until the issue is resolved or [QualityIssueLevel.None] when the issue has been resolved.
                * Event may be triggered intermittently and resolved just as spontaneously on less reliable networks, or during temporary disconnections.
                * Possible reasons:
                * - Network issues.
                * @hidden
                */
            interface ICEDisconnectedIssue extends CallEvent {
                    /**
                        * Issue level.
                        */
                    level: number;
            }
            /**
                * Reported in a handler function for [CallEvents.QualityIssueLocalVideoDegradation].
                * Reports that a video resolution being sent to an endpoint is lower than a captured video resolution, so it affects the quality of remote video or screen sharing on a remote participant side, but do not affect the quality of a local video preview.
                * The issue level may vary during the call.
                * Possible reasons:
                * - High CPU load during the video call.
                * - Network issues such as poor internet connection or low bandwidth.
                *
                * Only in Chrome for video
                * Only in Firefox for sharing
                * @hidden
                */
            interface LocalVideoDegradationIssue extends CallEvent {
                    /**
                        * Issue level.
                        */
                    level: number;
                    /**
                        * Type of stream.
                        */
                    kind: TrackType;
                    /**
                        * Optional. Video frame width set in [Config.videoConstraints].
                        */
                    targetWidth?: number;
                    /**
                        * Optional. Video frame height set in [Config.videoConstraints].
                        */
                    targetHeight?: number;
                    /**
                        * Optional. Sent video frame width.
                        */
                    actualWidth?: number;
                    /**
                        * Optional. Sent video frame height.
                        */
                    actualHeight?: number;
                    /**
                        * Optional. Sent sharing fps. 15 fps is maximum for sharing in Firefox. When fps if lower then 4, the issue level is [QualityIssueLevel.Critical], when fps is lower then 8, the issue level is [QualityIssueLevel.Major], when fps is lower than 15, the issue level is [QualityIssueLevel.Minor].
                        */
                    fps?: number;
            }
            /**
                * Reported in a handler function for [CallEvents.QualityIssueLowBandwidth].
                * Issue level may vary during the call. SDK may report [QualityIssueLevel.Major] or [QualityIssueLevel.Minor] while detecting network capabilities right after the call start.
                * Target bitrate depends on the outgoing video frame resolution. If the resolution of outgoing video frames is changed, target bitrate can also be changed (increased or degraded).
                * Possible reasons:
                * - Network issues.
                * - Background state of an application.
                * @hidden
                */
            interface LowBandwidthIssue extends CallEvent {
                    /**
                        * Issue level.
                        */
                    level: number;
                    /**
                        * Bitrate required to send video with current resolution with a good quality. Measured in bits per second.
                        */
                    targetBitrate: number;
                    /**
                        * Actual bitrate. Measured in bits per second.
                        */
                    actualBitrate: number;
            }
            /**
                * Reported in a handler function for [CallEvents.QualityIssueNoAudioSignal].
                * Issue level can be only [QualityIssueLevel.Critical] if the issue is detected or [QualityIssueLevel.None] if the issue is not detected or is already resolved.
                * Depending on the audio capturing device manufacturer, the issue may be occasionally reported in case of a pause in a conversation.
                * Possible reasons:
                * - Application or other library mutes the microphone via the muteMicrophone Web SDK API.
                *
                * Only in Chrome
                * @hidden
                */
            interface NoAudioSignalIssue extends CallEvent {
                    /**
                        * Issue level.
                        */
                    level: number;
            }
            /**
                * Reported in a handler function for [CallEvents.QualityIssuePacketLoss].
                * Packet loss can lead to missing of entire sentences, awkward pauses in the middle of a conversation or robotic voice during the call.
                * Issue level may vary during the call.
                * Possible reasons:
                * - Network congestion.
                * - Bad hardware (parts of the network infrastructure).
                * @hidden
                */
            interface PacketLossIssue extends CallEvent {
                    /**
                        * Issue level.
                        */
                    level: number;
                    /**
                        * Average packet loss for 2.5 seconds.
                        */
                    packetLoss: number;
            }
            interface CallStatsReceived extends CallEvent {
                    stats: StatsReport;
            }
            interface VoiceStart extends EndpointHandler {
            }
            interface VoiceEnd extends EndpointHandler {
            }
            interface MediaRenderEnabled extends EndpointMediaHandler {
            }
            interface MediaRenderDisabled extends EndpointMediaHandler {
                    /**
                        * The field describes why a media renderer has been disabled
                        */
                    reason: MediaRenderDisablingReason;
            }
            /**
                * @hidden
                */
            interface HardwareEvent {
                    /**
                        * @hidden
                        */
                    name: Hardware.HardwareEvents;
            }
            interface DevicesUpdated extends HardwareEvent {
                    /**
                        * List of currently available audio input devices, such as microphones
                        */
                    audioInputDevices: AudioSourceInfo[];
                    /**
                        * List of currently available audio output devices, such as speakers or headphones
                        */
                    audioOutputDevices: AudioSourceInfo[];
                    /**
                        * List of currently available video input devices, such as cameras
                        */
                    videoInputDevices: VideoSourceInfo[];
            }
            interface MediaRendererAdded extends HardwareEvent {
                    /**
                        * Media renderer that triggered the event
                        */
                    renderer: MediaRenderer;
            }
            interface MediaRendererUpdated extends HardwareEvent {
                    /**
                        * Media renderer that triggered the event
                        */
                    renderer: MediaRenderer;
                    /**
                        * Media renderer type, such as audio, video, or screen sharing
                        */
                    type: MediaRendererKind;
            }
            interface BeforeMediaRendererRemoved extends HardwareEvent {
                    /**
                        * Media renderer that triggered the event
                        */
                    renderer: MediaRenderer;
            }
            interface MediaRendererRemoved extends HardwareEvent {
                    /**
                        * Media renderer that triggered the event
                        */
                    renderer: MediaRenderer;
            }
    }
}

declare module 'voximplant-websdk/Media/MediaRenderer' {
    import { Call } from 'voximplant-websdk/Call/Call';
    import { Endpoint } from 'voximplant-websdk/Call/EndPoints/Endpoint';
    import { MediaRendererKind } from 'voximplant-websdk/Structures';
    /**
        * @hidden
        */
    interface MediaRendererOptions {
            stream: MediaStream;
            kind: MediaRendererKind;
            placeOnDom?: boolean;
            isLocal?: boolean;
            deprecatedId?: string;
            transceivers?: RTCRtpTransceiver[];
            mids?: string[];
    }
    /**
        * It is the wrapper for the HTMLMediaElement and its MediaStream.
        *   You can get this object on
        *   the [HardwareEvents.MediaRendererAdded] and
        *   [HardwareEvents.MediaRendererRemoved] for local media.
        *
        *   For remote media sources, you can get an instance
        *   of this object from [Endpoint] or
        *   [EndpointEvents.RemoteMediaAdded]
        *   or
        *   [EndpointEvents.RemoteMediaRemoved]
        */
    export class MediaRenderer {
            /**
                * HTML element where rendering is executed.
                */
            element: HTMLMediaElement;
            /**
                * A source stream sended from/to some Endpoint. The type of a stream is specified via the [MediaRenderer.kind] property.
                *
                * You can use the property for modifying and filtering source streams. E.g. for face masks and CV (computer vision).
                */
            stream: MediaStream;
            /**
                * Describe the tag and type of media that is placed in this container.
                *   <ul>
                *   <li>Kind "audio" means &lt;audio&gt; HTML element and sound-only media stream</li>
                *   <li>Kind "video" means &lt;video&gt; HTML element and either video-only or audio plus video media stream</li>
                *   <li>Kind "sharing" the same as kind "video", but literally tell you "This is screen sharing"</li>
                *   </ul>
                */
            kind: MediaRendererKind;
            /**
                * @hidden
                */
            placeOnDom: boolean;
            /**
                * Source of the media stream. Set to "true" for the local streams, "false" for the remote streams.
                */
            isLocal: boolean;
            /**
                * @hidden
                */
            transceivers: RTCRtpTransceiver[];
            /**
                * @hidden
                */
            mids?: ['local'] | string[];
            /**
                * Create new MediaRenderer for a local or a remote media stream
                * @hidden
                * @param options
                */
            constructor(options: MediaRendererOptions);
            /**
                * Unique ID of MediaRender
                */
            get id(): string;
            /**
                * @hidden
                */
            renderDefault(): void;
            get enabled(): boolean;
            /**
                * Starts receiving incoming media stream from the server if the one has been disabled via [MediaRenderer.disable]
                */
            enable(): void;
            /**
                * Stops receiving incoming media stream from the server. Trigger the [EndpointEvents.MediaRenderDisabled] event with the reason [MediaRenderDisablingReason.Manual]
                */
            disable(): void;
            /**
                * @hidden
                */
            conferenceEpManagerUpdateState: () => void;
            /**
                * @hidden
                */
            conferenceEpManagerUpdateRenderSize: () => void;
            /**
                * @hidden
                */
            simulcastMode: 'auto' | 'manual';
            /**
                * Returns the nearest simulcast layer to the requested resolution.
                * Only for conferences in the simulcast mode.
                */
            requestVideoSize(width: number, height: number): Promise<void>;
            videoSize: {
                    width: number;
                    height: number;
            };
            /**
                * Render (display) current instance of MediaRenderer to the HTMLElement in the DOM tree. If the container paramater is not specified, the method appends rendering to the body element.
                * The method allows to render manually in cases of:
                * 1. Default rendering is turned off. If you subscribe to the [EndpointEvents.RemoteMediaAdded] event, Web SDK no longer renders the remote audio/video stream automatically so you have to call this method with optional __container__ parameter.
                * 2. default rendering is active, but you want to change rendering container. Call the method with the specified HTMLElement.
                * @param {HTMLElement} container place for rendering.
                */
            render(container?: HTMLElement): void;
            /**
                * @hidden
                * @type {MediaStream}
                */
            replaceVideo(stream: MediaStream): void;
            /**
                * Destroy current unit and free resources.
                * @hidden
                */
            clear(): void;
            /**
                * Set current MediaRenderer output volume. The range is from 0 to 1.
                * @param {number} level
                */
            setVolume(level: number): void;
            /**
                * Set the output audio device for current MediaRenderer. ID can be retrieved via the [AudioDeviceManager.getOutputDevices] method.
                * @param {string} id`
                */
            useAudioOutput(id: string): Promise<void>;
            /**
                * Run when the current MediaRenderer unit is destroyed
                * @hidden
                */
            onDestroy: Function;
            /**
                * Run when the current MediaRenderer unit is destroyed
                * @hidden
                */
            onBeforeDestroy: Function;
            /**
                * @hidden
                * @return {string}
                * @private
                */
            _traceName(): string;
            playElement(): void;
            /**
                * @hidden
                * @private
                */
            pauseElement(): void;
            /**
                * @hidden
                * @private
                * @param call
                * @param endpoint
                */
            notifyAboutCreation(call: Call, endpoint: Endpoint): void;
    }
    export {};
}

declare module 'voximplant-websdk/Call/ViewerCall' {
    import { CallSettings, DisconnectingFlags } from 'voximplant-websdk/Structures';
    import { AbstractCall } from 'voximplant-websdk/Call/AbstractCall';
    import { Endpoint } from 'voximplant-websdk/Call/EndPoints/Endpoint';
    export class ViewerCall extends AbstractCall {
            /**
                * @hidden
                */
            peerConnection: RTCPeerConnection;
            /**
                * @hidden
                */
            constructor(id: string, sets: CallSettings);
            /**
                * Get all current [Endpoint]s in the call.
                * @returns {Endpoint[]}
                */
            getEndpoints(): Endpoint[];
            /**
                * @hidden
                * @param headers
                * @param params
                * @returns {boolean}
                */
            onDisconnected(headers: {
                    [id: string]: string;
            }, params: DisconnectingFlags): Promise<boolean>;
            /**
                * @hidden
                */
            onInfo(call: ViewerCall, type: string, subType: string, body: string, headers: {
                    [id: string]: string;
            }): boolean;
            /**
                * @hidden
                */
            processRemoteAnswer(sdp: any): Promise<void>;
            /**
                * @hidden
                * @return {string}
                * @private
                */
            _traceName(): string;
            /**
                * @hidden
                */
            canStartSendingCandidates(): void;
            /**
                * @hidden
                */
            onICECandidate(cand: RTCIceCandidate): void;
            /**
                * @hidden
                */
            addCandidateToSend(attrString: string, mLineIndex: number): void;
            /**
                * @hidden
                */
            sendInfo(mimeType: string, body: string, extraHeaders?: {
                    [id: string]: string;
            }): void;
    }
}

declare module 'voximplant-websdk/Call/SharingCall' {
    import { DisconnectingFlags, InnerCallSettings } from 'voximplant-websdk/Structures';
    import { AbstractCall } from 'voximplant-websdk/Call/AbstractCall';
    import { Endpoint } from 'voximplant-websdk/Call/EndPoints/Endpoint';
    /**
        * @hidden
        */
    export type SharingCallSettings = Pick<InnerCallSettings, 'audioDirections' | 'number' | 'extraHeaders'>;
    export class SharingCall extends AbstractCall {
            getEndpoints(): Endpoint[];
            /**
                * @hidden
                */
            peerConnection: RTCPeerConnection;
            /**
                * @hidden
                */
            constructor(id: string, sets: SharingCallSettings);
            /**
                * @hidden
                * @param headers
                * @param params
                * @returns {boolean}
                */
            onDisconnected(headers: {
                    [id: string]: string;
            }, params: DisconnectingFlags): Promise<boolean>;
            /**
                * @hidden
                */
            onInfo(call: SharingCall, type: string, subType: string, body: string, headers: {
                    [id: string]: string;
            }): boolean;
            /**
                * @hidden
                */
            processRemoteAnswer(sdp: any): Promise<void>;
            /**
                * @hidden
                * @return {string}
                * @private
                */
            _traceName(): string;
            /**
                * @hidden
                */
            canStartSendingCandidates(): void;
            /**
                * @hidden
                */
            addCandidateToSend(attrString: string, mLineIndex: number): void;
            /**
                * @hidden
                */
            sendInfo(mimeType: string, body: string, extraHeaders?: {
                    [id: string]: string;
            }): void;
    }
}

declare module 'voximplant-websdk/PeerConnection/SDP/Interfaces' {
    /**
        * Created by irbisadm on 15/04/16.
        */
    import { SdpAttribute } from 'voximplant-websdk/PeerConnection/SDP/ParserSDP/Interfaces';
    /**
        * Parsed sections with parsed codecs
        * @hidden
        */
    export interface CodecSorterCodecList {
            /**
                * part of sdp before media section
                */
            prefix: string;
            /**
                * Media sections
                */
            sections: Array<CodecSorterSection>;
    }
    /**
        * Parsed section of codec
        * @hidden
        */
    export interface CodecSorterSection {
            /**
                * kind of media section
                * @see https://tools.ietf.org/html/rfc4566#section-5.14
                */
            kind: any;
            /**
                * First line without codec order
                */
            firstLine: string;
            /**
                * Part of media section before codec
                */
            prefix: string;
            /**
                * List of codec parsed by /r/n point
                */
            codec: Array<Array<string>>;
            /**
                * Part of media section after codec definition
                */
            sufix: string;
    }
    /**
        * Object holding media section for sorting by end user
        * @hidden
        */
    export interface CodecSorterUserCodecList {
            /**
                * List of sections for end user
                */
            sections: CodecSorterUserSections[];
    }
    /**
        *  Description of one media section
        *  @hidden
        */
    export interface CodecSorterUserSections {
            /**
                * kind of media - list accepted media shorted for "audio" and "video"
                */
            kind: 'audio' | 'video';
            /**
                * list of payload description for end user
                */
            codec: SdpAttribute[];
    }
    export interface CodecDescription {
            /**
                * Codec name
                */
            name: string;
            /**
                * Optional. Codec parameters
                */
            params?: {
                    [key: string]: string;
            };
            /**
                * Optional. Whether the codec is optional
                */
            optional?: boolean;
    }
}

declare module 'voximplant-websdk/LoginStateEnum' {
    /**
      * Possible client login state.
      * @hidden
      */
    export enum LoginState {
        LOGGED_OFF = 0,
        LOGGING_IN = 1,
        LOGGED_IN = 2
    }
}

declare module 'voximplant-websdk/Messaging/src/Messenger' {
    import Messaging from 'voximplant-websdk/Messaging';
    import { MsgEvent } from 'voximplant-websdk/Signaling/MsgEvent';
    import { Conversation } from 'voximplant-websdk/Messaging/src/Conversation';
    import { Message } from 'voximplant-websdk/Messaging/src/Message';
    import { ConversationParticipant, SerializedConversation, SerializedMessage } from 'voximplant-websdk/Messaging/src/Structures';
    /**
        * @hidden
        */
    export class Messenger {
            /**
                * @hidden
                */
            static rejectTimeout: number;
            /**
                * @hidden
                */
            constructor();
            /**
                * @hidden
                */
            static getInstance(): Messenger;
            /**
                * Register a handler for the specified event.
                * @hidden
                * @deprecated
                * @param event Event identifier
                * @param handler JavaScript function to be called when the specified Triggered. Please note that function is called without 'this' binding.
                */
            addEventListener(event: Messaging.MessengerEvents, handler: Function): void;
            /**
                * Remove a handler for the specified event.
                * @hidden
                * @deprecated
                * @param event Event identifier
                * @param handler Reference to the JavaScript function to remove from event listeners. If not specified, removes all event listeners from the specified event.
                */
            removeEventListener(event: Messaging.MessengerEvents, handler?: Function): void;
            /**
                * Register a handler for any of the [MessengerEvents].
                * One event can have more than one handler. Handlers are executed in the order of registration.
                * Use the [Messenger.off] method to remove a handler.
                * @param event
                * @param handler
                */
            on(event: Messaging.MessengerEvents, handler: Function): void;
            /**
                * Remove a handler for one of the [MessengerEvents].
                * If a number of events has the same function as a handler, the method can be called multiple times with the same handler argument.
                * @param event
                * @param handler
                */
            off(event: Messaging.MessengerEvents, handler?: Function): void;
            /**
                * @hidden
                * @param event
                * @param payload
                */
            _dispatchEvent<E extends Messaging.MessengerEvents>(event: E, payload: Messaging.MessengerEventsPayload<E>, uuid?: string): void;
            /**
                * Add new promise for awaiting.
                * @param uuid
                * @param resolve
                * @param reject
                * @hidden
                */
            _registerPromise(uuid: string, resolve: Function, reject: Function): void;
            /**
                * Get a conversation by its UUID.
                * Triggers the [MessengerEvents.GetConversation] event.
                * To get the result, use one of these options:
                * - Subscribe to the [MessengerEvents.GetConversation] event and provide a handler consuming an object with the [EventHandlers.GetConversationEvent] interface as a parameter.
                * - Handle the returned promise (recommended).
                * Rejects to a [Messaging.MessengerError] if the requested conversation is not public (see [Conversation.publicJoin]) or the current user is not/has not been a participant of the non-public conversation.
                * @see [MessengerEvents.GetConversation], [MessengerEvents.Error]
                * @param uuid
                * @returns {Promise<EventHandlers.GetConversationEvent>|Promise}
                */
            getConversation(uuid: string): Promise<Messaging.EventHandlers.GetConversationEvent>;
            /**
                * Get the multiple conversations by an array of UUIDs. Maximum 30 conversation.
                * Triggers multiple [MessengerEvents.GetConversation] events.
                * To get the result, use one of these options:
                * - Subscribe to the [MessengerEvents.GetConversation] event and provide a handler consuming an object with the [EventHandlers.GetConversationEvent] interface as a parameter.
                * - Handle the returned promise (recommended).
                * Rejects to a [Messaging.MessengerError] if the requested conversations are not public (see [Conversation.publicJoin]) or the current user is not/has not been a participant any requested non-public conversation.
                * @see [MessengerEvents.GetConversation], [MessengerEvents.Error]
                * @param conversations Array of conversation UUIDs. Maximum 30 conversations.
                * @returns {Promise<Array<Messaging.EventHandlers.GetConversationEvent>>|Promise}
                */
            getConversations(conversations: Array<string>): Promise<Array<Messaging.EventHandlers.GetConversationEvent>>;
            /**
                * Get UUIDs of all public conversations (see [Conversation.publicJoin]) created by the current user, other users of the same child account or any user of the main Voximplant developer account.
                * Triggers  [MessengerEvents.GetPublicConversations] events.
                * To get te result, use one of these options:
                * - Subscribe to the [MessengerEvents.GetPublicConversations] event and provide a handler consuming an object with the [EventHandlers.GetPublicConversationsEvent] interface as a parameter.
                * - Handle the returned promise (recommended).
                * @returns {Promise<EventHandlers.GetPublicConversationsEvent>|Promise}
                */
            getPublicConversations(): Promise<Messaging.EventHandlers.GetPublicConversationsEvent>;
            /**
                * @hidden
                */
            getRawConversations(conversations: Array<string>): Promise<Messaging.EventHandlers.GetConversationEvent[]>;
            /**
                * Create a new conversation.
                * The creator of any conversation by default:
                * - is an owner (see [ConversationParticipant.isOwner])
                * - can write messages
                * - can edit and remove own and other participants' messages
                * - can manage conversation participants
                * Triggers either the [MessengerEvents.CreateConversation] event on for all parties of the conversation (online participants and logged in clients) which are in 'participants' array.
                * To get the result, use one of these options:
                * - Subscribe to the [MessengerEvents.CreateConversation] event and provide a handler consuming an object with the [EventHandlers.CreateConversationEvent] interface as a parameter.
                * Remember that [MessengerEvents.CreateConversation] may be triggered by another user , so check the 'initiator' field.
                * - Handle the returned promise. Though you still need to listen to [MessengerEvents.CreateConversation] event to handle events from other parties.
                * Rejects to a [Messaging.MessengerError] if
                * - at least one user in array of participants does not exist or is not a user of the main Voximplant developer account or its child accounts,
                * - the specified parameters are contradicting (e.g. 'direct' and 'publicJoin' are both true).
                * @see [MessengerEvents.CreateConversation], [MessengerEvents.Error]
                * @param participants Array of participants alongside with access rights params. If all flags are set to false or undefined, [ConversationParticipant.canWrite], [ConversationParticipant.canEdit] and [ConversationParticipant.canRemove] are set to true by default.
                * @param title Conversation title
                * @param direct Whether the conversation is between two users only. A direct conversation cannot be public or uber. See [Conversation.direct].
                * @param enablePublicJoin Whether any user can join the conversation by its uuid. See [Conversation.publicJoin].
                * @param uberConversation Whether the conversation restricts access to messages. See [Conversation.uberConversation].
                * @param customData JavaScript object with custom data, up to 5Kb.
                * @returns {Promise<EventHandlers.CreateConversationEvent>|Promise}
                */
            createConversation(participants: Array<ConversationParticipant>, title?: string, direct?: boolean, publicJoin?: boolean, uber?: boolean, customData?: object): Promise<Messaging.EventHandlers.CreateConversationEvent>;
            /**
                * Restore the conversation from cache that has been previously serialized by the [Conversation.toCache] method.
                * @param cachedConversation A JavaScript object for a serialized conversation
                * @returns {Conversation}
                */
            createConversationFromCache(cachedConversation: SerializedConversation): Conversation;
            /**
                * Add the current user to the conversation specified by the UUID.
                * Triggers the [MessengerEvents.EditConversation] event for all parties of the conversation (online participants and logged in clients).
                * To get the result, use one of these options:
                * - Subscribe to the [MessengerEvents.EditConversation] event and provide a handler consuming an object with the [EventHandlers.EditConversationEvent] interface as a parameter.
                * Remember that [MessengerEvents.EditConversation] may be triggered by another user and as a result of a number of other methods. So check 'messengerAction' and 'initiator' fields.
                * - Handle the returned promise. Though you still need to listen to [MessengerEvents.EditConversation] event to handle events from other parties.
                * Rejects to a [Messaging.MessengerError] if
                * - the conversation has been created not by a user of the main Voximplant developer account or its child accounts,
                * - public join is disabled for the conversation (see [Conversation.publicJoin]),
                * - the conversation is direct (see [Conversation.direct]).
                * @see [MessengerEvents.EditConversation], [MessengerEvents.Error]
                * @param uuid Universally Unique Identifier of the conversation
                * @returns {Promise<EventHandlers.EditConversationEvent>|Promise}
                */
            joinConversation(uuid: string): Promise<Messaging.EventHandlers.EditConversationEvent>;
            /**
                * Remove the current user from the conversation specified by the UUID.
                * Triggers the [MessengerEvents.EditConversation] event for all parties of the conversation (online participants and logged in clients).
                * To get the result, use one of these options:
                * - Subscribe to the [MessengerEvents.EditConversation] event and provide a handler consuming an object with the [EventHandlers.EditConversationEvent] interface as a parameter.
                * Remember that [MessengerEvents.EditConversation] may be triggered by another user and as a result of a number of other methods. So check 'messengerAction' and 'initiator' fields.
                * - Handle the returned promise. Though you still need to listen to [MessengerEvents.EditConversation] event to handle events from other parties.
                * Rejects to a [Messaging.MessengerError] if the conversation is direct (see [Conversation.direct]).
                * @see [MessengerEvents.EditConversation], [MessengerEvents.Error]
                * @param uuid  Universally Unique Identifier of the conversation
                * @returns {Promise<EventHandlers.EditConversationEvent>|Promise}
                */
            leaveConversation(uuid: string): Promise<Messaging.EventHandlers.EditConversationEvent>;
            /**
                * Get the Voximplant user identifier for the current user (e.g. 'username@appname.accname').
                * @returns {string} Voximplant user identifier for the current user, or null if the client is not logged in
                */
            getMe(): string;
            /**
                * Get the Messaging user id for the current user.
                * Triggers the [MessengerEvents.GetUser] event.
                * To get the result, use one of these options:
                * - Subscribe to the [MessengerEvents.GetUser] event and provide a handler consuming an object with the [EventHandlers.GetUserEvent] interface as a parameter.
                * - Handle the returned promise (recommended).
                * @returns {Promise<number>|Promise} Messaging user id
                */
            getMyId(): Promise<number>;
            /**
                * Get [User] information for the user specified by the Voximplant user name (e.g. 'username@appname.accname').
                * It is possible to get any user of the main Voximplant developer account or its child accounts.
                * Triggers the [MessengerEvents.GetUser] event.
                * To get the result, use one of these options:
                * - Subscribe to the [MessengerEvents.GetUser] event and provide a handler consuming an object with the [EventHandlers.GetUserEvent] interface as a parameter.
                * - Handle the returned promise (recommended).
                * @param user_name User name
                * @returns {Promise<EventHandlers.GetUserEvent>|Promise}
                */
            getUser(userName: string): Promise<Messaging.EventHandlers.GetUserEvent>;
            /**
                * Get [User] information for the user specified by the Messaging user id.
                * It is possible to get any user of the main Voximplant developer account or its child accounts.
                * Triggers the [MessengerEvents.GetUser] event.
                * To get the result, use one of these options:
                * - Subscribe to the [MessengerEvents.GetUser] event and provide a handler consuming an object with the [EventHandlers.GetUserEvent] interface as a parameter.
                * - Handle the returned promise (recommended).
                * @param userId Messaging user id
                * @returns {Promise<EventHandlers.GetUserEvent>|Promise}
                */
            getUserById(userId: number): Promise<Messaging.EventHandlers.GetUserEvent>;
            /**
                * Get [User] information for the users specified by an array of the Voximplant user names (e.g. 'username@appname.accname'). Maximum 50 users.
                * It is possible to get any users of the main Voximplant developer account or its child accounts.
                * Triggers multiple [MessengerEvents.GetUser] events.
                * To get the result, use one of these options:
                * - Subscribe to the [MessengerEvents.GetUser] event and provide a handler consuming an object with the [EventHandlers.GetUserEvent] interface as a parameter.
                * - Handle the returned promise (recommended).
                * @param users Array of the Voximplant user names (e.g. 'username@appname.accname'). Maximum 50 users.
                * @returns {Promise<Array<Messaging.EventHandlers.GetUserEvent>>|Promise}
                */
            getUsers(users: Array<string>): Promise<Array<Messaging.EventHandlers.GetUserEvent>>;
            /**
                * Get [User] information for the users specified by an array of Messaging user ids. Maximum 50 users.
                * It is possible to get any users of the main Voximplant developer account or its child accounts.
                * Triggers multiple [MessengerEvents.GetUser] events.
                * To get the result, use one of these options:
                * - Subscribe to the [MessengerEvents.GetUser] event and provide a handler consuming an object with the [EventHandlers.GetUserEvent] interface as a parameter.
                * - Handle the returned promise (recommended).
                * @param users Array of Messaging user ids. Maximum 50 users.
                * @returns {Promise<Array<Messaging.EventHandlers.GetUserEvent>>|Promise}
                */
            getUsersById(userIds: Array<number>): Promise<Array<Messaging.EventHandlers.GetUserEvent>>;
            /**
                * Edit the current user information.
                * Triggers the [MessengerEvents.EditUser] event for all parties of the conversation (online participants and logged in clients).
                * To get the result, use one of these options:
                * - Subscribe to the [MessengerEvents.EditUser] event and provide a handler consuming an object with the [EventHandlers.EditUserEvent] interface as a parameter.
                * Remember that [MessengerEvents.EditUser] may be triggered by another user, so check the 'initiator' field.
                * - Handle the returned promise. Though you still need to listen to [MessengerEvents.EditUser] event to handle events from other parties.
                * @param customData Public custom data available to any user. If null or undefined, previously set custom data is not changed. If an empty object, previously set custom data is removed.
                * @param privateCustomData Private custom data available only to the current user. If null or undefined, previously set custom data is not changed. If an empty object, previously set custom data is removed.
                * @returns {Promise<EventHandlers.EditUserEvent>|Promise}
                */
            editUser(customData?: Object, privateCustomData?: Object): Promise<Messaging.EventHandlers.EditUserEvent>;
            /**
                * Set the current user presence status.
                * Triggers the [MessengerEvents.SetStatus] event for all parties of the conversation (online participants and logged in clients) which are subscribed on this user.
                * To get the result, use one of these options:
                * - Subscribe to the [MessengerEvents.SetStatus] event and provide a handler consuming an object with the [EventHandlers.SetStatusEvent] interface as a parameter.
                * Remember that [MessengerEvents.SetStatus] may be triggered by another user, so check the 'initiator' field.
                * - Handle the returned promise. Though you still need to listen to [MessengerEvents.SetStatus] event to handle events from other parties.
                * @param online Whether the user is available for messaging.
                * @returns {Promise<EventHandlers.SetStatusEvent>|Promise}
                */
            setStatus(online: boolean): Promise<Messaging.EventHandlers.SetStatusEvent>;
            /**
                * Subscribe for other user(s) information and status changes.
                * It is possible to subscribe for any user of the main Voximplant developer account or its child accounts.
                * Triggers the [MessengerEvents.Subscribe] event for all parties of the conversation (online participants and logged in clients).
                * To get the result, use one of these options:
                * - Subscribe to the [MessengerEvents.Subscribe] event and provide a handler consuming an object with the [EventHandlers.SubscribeEvent] interface as a parameter.
                * Remember that [MessengerEvents.Subscribe] may be triggered by another user, so check the 'initiator' field.
                * - Handle the returned promise. Though you still need to listen to [MessengerEvents.Subscribe] event to handle events from other parties.
                * @param users Array of Messaging user ids.
                * @returns {Promise<EventHandlers.SubscribeEvent>|Promise}
                */
            subscribe(users: Array<number>): Promise<Messaging.EventHandlers.SubscribeEvent>;
            /**
                * Unsubscribe from other user(s) information and status changes.
                * Triggers the [MessengerEvents.Unsubscribe] event for all parties of the conversation (online participants and logged in clients).
                * To get the result, use one of these options:
                * - Subscribe to the [MessengerEvents.Unsubscribe] event and provide a handler consuming an object with the [EventHandlers.UnsubscribeEvent] interface as a parameter.
                * Remember that [MessengerEvents.Subscribe] may be triggered by another user, so check the 'initiator' field.
                * - Handle the returned promise. Though you still need to listen to [MessengerEvents.Unsubscribe] event to handle events from other parties.
                * @param users Array of Messaging user ids.
                * @param all If true, an array of user ids is ignored and the current user is unsubscribed from all the conversation users.
                * @returns {Promise<EventHandlers.UnsubscribeEvent>|Promise}
                */
            unsubscribe(users: Array<number>, all?: boolean): Promise<Messaging.EventHandlers.UnsubscribeEvent>;
            /**
                * Get the list of users the current user is subscribed to.
                * Triggers the [MessengerEvents.GetSubscriptionList] event.
                * To get the result, use one of these options:
                * - Subscribe to the [MessengerEvents.GetSubscriptionList] event and provide a handler consuming an object with the [EventHandlers.GetSubscriptionListEvent] interface as a parameter.
                * - Handle the returned promise (recommended).
                * @returns {Promise<EventHandlers.GetSubscriptionListEvent>|Promise}
                */
            getSubscriptionList(): Promise<Messaging.EventHandlers.GetSubscriptionListEvent>;
            /**
                * Manage push notifications on Messenger events for the current user.
                * Only subscriptions to the [MessengerEvents.CreateConversation], [MessengerEvents.SendMessage] and [MessengerEvents.EditMessage] events are available.
                * \nNote that you need to set up push notifications to use this method.
                * You can find all the setup steps in our [Push Notifications tutorial](/docs/references/websdk/push-notifications).
                * Triggers the [MessengerEvents.EditConversation] event for all parties of the conversation (online participants and logged in clients).
                * To get the result, use one of these options:
                * - Subscribe to the [MessengerEvents.EditConversation] event and provide a handler consuming an object with the [EventHandlers.EditConversationEvent] interface as a parameter.
                * Remember that [MessengerEvents.EditConversation] may be triggered by another user and as a result of a number of other methods. So check 'messengerAction' and 'initiator' fields.
                * - Handle the returned promise. Though you still need to listen to [MessengerEvents.EditConversation] event to handle events from other parties.
                * @returns {Promise<EventHandlers.ManageNotifications>|Promise}
                */
            manageNotification(notifications: Array<Messaging.MessengerEvents>): Promise<Messaging.EventHandlers.EditUserEvent>;
            /**
                * Restore a [Message] from its serialisation previously created by the [Message.toCache] method.
                * @param cachedMessage A JavaScript object for a serialized message
                * @returns {Message}
                */
            createMessageFromCache(cachedMessage: SerializedMessage): Message;
            /**
                * @hidden
                */
            reject(errorCode: Messaging.MessengerError, action: Messaging.MessengerAction): Promise<Messaging.EventHandlers.ErrorEvent>;
            /**
                * @hidden
                */
            msgEventToMessengerEvent(e: MsgEvent): Messaging.MessengerEvents;
            /**
                * @hidden
                * @return {string}
                * @private
                */
            _traceName(): string;
    }
}

declare module 'voximplant-websdk/Messaging/src/Conversation' {
    import { MsgInput, MsgOutput, SerializedConversation, ConversationParticipant } from 'voximplant-websdk/Messaging/src/Structures';
    import Messaging from 'voximplant-websdk/Messaging';
    /**
        * @hidden
        */
    export class Conversation {
            /**
                * The universally unique identifier (UUID) of the conversation.
                * @returns {string}
                */
            get uuid(): string;
            get title(): string;
            /**
                * The conversation title.
                * Note that setting this property does not send changes to the server. Use the [Conversation.update] method to send all the changes at once or [Conversation.setTitle] to update only the title.
                * @param value
                */
            set title(value: string);
            /**
                * UNIX timestamp (seconds) that specifies the time the conversation has been created.
                */
            get createdAt(): number;
            /**
                * UNIX timestamp (seconds) that specifies the time of the last event in the conversation.
                */
            get lastUpdate(): any;
            /**
                * A direct conversation includes only 2 participants. There cannot be more than 1 direct conversation between the same 2 users.
                * If one of these users tries to create a new direct conversation with the same participant via [Messenger.createConversation], the method returns the existing direct conversation.
                * A direct conversation cannot be uber and/or public.
                */
            get direct(): boolean;
            /**
                * Users in a uber conversation are not able to retrieve messages that have been posted to the conversation after they quit or before they joined.
                * A uber conversation cannot be direct.
                */
            get uberConversation(): boolean;
            get publicJoin(): boolean;
            /**
                * If true, anyone can join the conversation by UUID.
                * A public conversation cannot be direct.
                * Note that setting this property does not send changes to the cloud. Use the [Conversation.update] method to send all changes at once or [Conversation.setPublicJoin] to update only the public join property.
                * @param value
                */
            set publicJoin(value: boolean);
            /**
                * The list of conversation participants alongside with their rights.
                * The default permissions for all participants are: write / edit / remove their own messages (see [ConversationParticipant.canWrite], [ConversationParticipant.canEdit] and [ConversationParticipant.canRemove]).
                * The creator of the conversation is an owner by default.
                * An owner of the conversation (see [ConversationParticipant.isOwner]):
                * - can write messages
                * - can edit and remove own and other participants' messages
                * - can manage conversation participants
                */
            get participants(): Array<ConversationParticipant>;
            get customData(): any;
            /**
                * Any JavaScript structure with custom data, up to 5Kb.
                * Note that setting this property does not send changes to the cloud.
                * Use the [Conversation.update] method to send all changes at once or [Conversation.setCustomData] to update just the custom data.
                * @param value
                */
            set customData(value: any);
            /**
                * The sequence of the last event in the conversation.
                */
            get lastSeq(): any;
            /**
                * @hidden
                */
            constructor(data: {
                    participants: Array<ConversationParticipant>;
            } & Partial<SerializedConversation>);
            /**
                * @hidden
                * @param newSeq
                */
            updateSeq(newSeq: number): void;
            /**
                * Create conversation from buss
                * @param busConversation
                * @returns {Conversation}
                * @hidden
                */
            static _createFromBus(busConversation: MsgOutput.Conversation, seq: number): Conversation;
            /**
                * Restore conversation from cache
                * @param cacheConversation
                * @returns {Conversation}
                * @hidden
                */
            static createFromCache(cacheConversation: SerializedConversation): Conversation;
            /**
                * Serialize the conversation so it can be stored (e.g. in IndexedDB) and restored later via the [Messenger.createConversationFromCache] method.
                * @returns {SerializedConversation}
                */
            toCache(): SerializedConversation;
            /**
                * @hidden
                */
            _getCreatePayload(): MsgInput.CreateConversation;
            /**
                *
                * @hidden
                */
            _getEditPayload(): MsgInput.EditConversation;
            /**
                * @hidden
                * Revert changes if [Conversation.update], [Conversation.setTitle], [Conversation.setPublicJoin] or [Conversation.setCustomData] fails.
                */
            _revertChanges(): void;
            /**
                * Send changes made via modifying conversation properties ([Conversation.title], [Conversation.publicJoin] and [Conversation.customData]) to the cloud.
                * Triggers the [MessengerEvents.EditConversation] event.
                * To get the result, use one of these options:
                * - Subscribe to the [MessengerEvents.EditConversation] event and provide a handler consuming an object with the [EventHandlers.EditConversationEvent] interface as a parameter.
                * Remember that [MessengerEvents.EditConversation] may be triggered by another user and as a result of a number of other methods. So check 'messengerAction' and 'initiator' fields.
                * - Handle the returned promise. Though you still need to listen to [MessengerEvents.EditConversation] event to handle events from other parties.
                * Rejects to a [Messaging.MessengerError] if the current user is not an owner of the conversation (see [ConversationParticipant.isOwner])
                * @returns {Promise<EventHandlers.EditConversationEvent>|Promise}
                */
            update(): Promise<Messaging.EventHandlers.EditConversationEvent>;
            /**
                * Set a new title for the current conversation.
                * Triggers the [MessengerEvents.EditConversation] event.
                * To get the result, use one of these options:
                * - Subscribe to the [MessengerEvents.EditConversation] event and provide a handler consuming an object with the [EventHandlers.EditConversationEvent] interface as a parameter.
                * Remember that [MessengerEvents.EditConversation] may be triggered by another user and as a result of a number of other methods. So check 'messengerAction' and 'initiator' fields.
                * - Handle the returned promise. Though you still need to listen to [MessengerEvents.EditConversation] event to handle events from other parties.
                * Rejects to a [Messaging.MessengerError] if the current user is not an owner of the conversation (see [ConversationParticipant.isOwner])
                * @returns {Promise<EventHandlers.EditConversationEvent>|Promise}
                */
            setTitle(title: string): Promise<Messaging.EventHandlers.EditConversationEvent>;
            /**
                * Set the public join flag and send changes to the server.
                * Triggers the [MessengerEvents.EditConversation] event.
                * To get the result, use one of these options:
                * - Subscribe to the [MessengerEvents.EditConversation] event and provide a handler consuming an object with the [EventHandlers.EditConversationEvent] interface as a parameter.
                * Remember that [MessengerEvents.EditConversation] may be triggered by another user and as a result of a number of other methods. So check 'messengerAction' and 'initiator' fields.
                * - Handle the returned promise. Though you still need to listen to [MessengerEvents.EditConversation] event to handle events from other parties.
                * Rejects to a [Messaging.MessengerError] if the current user is not an owner of the conversation (see [ConversationParticipant.isOwner])
                * @returns {Promise<EventHandlers.EditConversationEvent>|Promise}
                */
            setPublicJoin(publicJoin: boolean): Promise<Messaging.EventHandlers.EditConversationEvent>;
            /**
                * Set new custom data for the conversation.
                * Triggers the [MessengerEvents.EditConversation] event.
                * To get the result, use one of these options:
                * - Subscribe to the [MessengerEvents.EditConversation] event and provide a handler consuming an object with the [EventHandlers.EditConversationEvent] interface as a parameter.
                * Remember that [MessengerEvents.EditConversation] may be triggered by another user and as a result of a number of other methods. So check 'messengerAction' and 'initiator' fields.
                * - Handle the returned promise. Though you still need to listen to [MessengerEvents.EditConversation] event to handle events from other parties.
                * Rejects to a [Messaging.MessengerError] if the current user is not an owner of the conversation (see [ConversationParticipant.isOwner])
                * @returns {Promise<EventHandlers.EditConversationEvent>|Promise}
                */
            setCustomData(customData: any): Promise<Messaging.EventHandlers.EditConversationEvent>;
            /**
                * Add new participants to the conversation. Duplicated users are ignored.
                * Triggers the [MessengerEvents.EditConversation] event for all parties of the conversation (online participants and logged in clients).
                * To get the result, use one of these options:
                * - Subscribe to the [MessengerEvents.EditConversation] event and provide a handler consuming an object with the [EventHandlers.EditConversationEvent] interface as a parameter.
                * Remember that [MessengerEvents.EditConversation] may be triggered by another user and as a result of a number of other methods. So check 'messengerAction' and 'initiator' fields.
                * - Handle the returned promise. Though you still need to listen to [MessengerEvents.EditConversation] event to handle events from other parties.
                * Rejects to a [Messaging.MessengerError] if
                * - at least one user does not exist or already belongs to the conversation,
                * - at least one participant is not a user of the main Voximplant developer account or its child accounts,
                * - the current user cannot manage other participants (see [ConversationParticipant.canManageParticipants] and [ConversationParticipant.isOwner]),
                * - the conversation is direct (see [Conversation.direct]).
                * @param participants
                * @returns {Promise<EventHandlers.EditConversationEvent>|Promise}
                */
            addParticipants(participants: Array<ConversationParticipant>): Promise<Messaging.EventHandlers.EditConversationEvent>;
            /**
                * Change permissions for conversation participants. Duplicated users are ignored.
                * This method does not add or remove participants. Use the [Conversation.addParticipants] and [Conversation.removeParticipants] methods instead.
                * Triggers the [MessengerEvents.EditConversation] event for all parties of the conversation (online participants and logged in clients).
                * To get the result, use one of these options:
                * - Subscribe to the [MessengerEvents.EditConversation] event and provide a handler consuming an object with the [EventHandlers.EditConversationEvent] interface as a parameter.
                * Remember that [MessengerEvents.EditConversation] may be triggered by another user and as a result of a number of other methods. So check 'messengerAction' and 'initiator' fields.
                * - Handle the returned promise. Though you still need to listen to [MessengerEvents.EditConversation] event to handle events from other parties.
                * Rejects to a [Messaging.MessengerError] if the current user cannot manage other participants (see [ConversationParticipant.canManageParticipants]).
                * @param participants
                * @returns {Promise<EventHandlers.EditConversationEvent>|Promise}
                */
            editParticipants(participants: Array<ConversationParticipant>): Promise<Messaging.EventHandlers.EditConversationEvent>;
            /**
                * Remove participants from the conversation. Duplicated users are ignored.
                * Will fail if any user does not exist.
                * Triggers the [MessengerEvents.EditConversation] event for all parties of the conversation (online participants and logged in clients).
                * To get the result, use one of these options:
                * - Subscribe to the [MessengerEvents.EditConversation] event and provide a handler consuming an object with the [EventHandlers.EditConversationEvent] interface as a parameter.
                * Remember that [MessengerEvents.EditConversation] may be triggered by another user and as a result of a number of other methods. So check 'messengerAction' and 'initiator' fields.
                * - Handle the returned promise. Though you still need to listen to [MessengerEvents.EditConversation] event to handle events from other parties.
                * Rejects to a [Messaging.MessengerError] if:
                * - the current user cannot manage other participants (see [ConversationParticipant.canManageParticipants]),
                * - the conversation is direct (see [Conversation.direct]),
                * - at least one user does not exist or already removed to the conversation,
                * @param participants
                * @returns {Promise<EventHandlers.EditConversationEvent>|Promise}
                */
            removeParticipants(participants: Array<ConversationParticipant>): Promise<Messaging.EventHandlers.EditConversationEvent>;
            /**
                * Send a message to the conversation.
                * Triggers the [MessengerEvents.SendMessage] event for all parties of the conversation (online participants and logged in clients).
                * To get the result, use one of these options:
                * - Subscribe to the [MessengerEvents.SendMessage] event and provide a handler consuming an object with the [EventHandlers.SendMessageEvent] interface as a parameter.
                * Remember that [MessengerEvents.SendMessage] may be triggered by another user, so check the 'initiator' field.
                * - Handle the returned promise. Though you still need to listen to [MessengerEvents.SendMessage] event to handle events from other parties.
                * Rejects to a [Messaging.MessengerError] if the current user does not have write permissions see [ConversationParticipant.canWrite] and [ConversationParticipant.isOwner]).
                * @param test Message text, maximum 5000 characters
                * @param payload Custom payload; can be an array of any objects, but not primitive types
                * @returns {Promise<EventHandlers.SendMessageEvent>|Promise}
                */
            sendMessage(text: string, payload?: Array<Object>): Promise<Messaging.EventHandlers.SendMessageEvent>;
            /**
                * Inform the cloud that the user is typing some text.
                * The minimum interval between the two method calls should be 10 seconds.
                * Triggers the [MessengerEvents.Typing] event for all parties of the conversation (online participants and logged in clients).
                * To get the result, use one of these options:
                * - Subscribe to the [MessengerEvents.Typing] event and provide a handler consuming an object with the [EventHandlers.TypingEvent] interface as a parameter.
                * Remember that [MessengerEvents.Typing] may be triggered by another user, so check the 'initiator' field.
                * - Handle the returned promise. Though you still need to listen to [MessengerEvents.Typing] event to handle events from other parties.
                * Rejects to a [Messaging.MessengerError] if the method is called within 10s since the last call.
                * Calls within 10s interval from the last call are discarded.
                * @returns {Promise<EventHandlers.TypingEvent | false>|Promise} Resolves to [EventHandlers.TypingEvent] if notification is actually sent to the server, 'false' if discarded.
                */
            typing(): Promise<Messaging.EventHandlers.TypingEvent | false>;
            /**
                * Mark the event which has the specified sequence as read.
                * This affects the current participant's [ConversationParticipant.lastRead] property and can be used to display unread messages.
                * Triggers the [MessengerEvents.Read] event for all parties of the conversation (online participants and logged in clients).
                * To get the result, use one of these options:
                * - Subscribe to the [MessengerEvents.Read] event and provide a handler consuming an object with the [EventHandlers.ReadEvent] interface as a parameter.
                * Remember that [MessengerEvents.Read] may be triggered by another user, so check the 'initiator' field.
                * - Handle the returned promise. Though you still need to listen to [MessengerEvents.Read] event to handle events from other parties.
                * @param seq
                * @returns {Promise<EventHandlers.ReadEvent>|Promise}
                */
            markAsRead(seq: number): Promise<Messaging.EventHandlers.ReadEvent>;
            /**
                * Request events in the specified sequence range to be sent from the cloud to this client.
                * Only [MessengerEvents.CreateConversation], [MessengerEvents.EditConversation], [MessengerEvents.SendMessage] and [MessengerEvents.EditMessage] events can be retransmitted; any other events cannot.
                * The method is used to get history or missed events in case of network disconnect.
                * Client should use this method to request all events based on the last conversation event sequence received from the cloud and last event sequence saved locally (if any).
                * If the current user quits an uber conversation (see [Conversation.uberConversation]), messages that has been posted during the user's absence are not retransmitted later.
                * The maximum number for requested events per method call is 100.
                * Triggers multiple [MessengerEvents.RetransmitEvents] events (for each retransmitted event).
                * To get the result, use one of these options:
                * - Subscribe to the [MessengerEvents.RetransmitEvents] event and provide a handler consuming an object with the [EventHandlers.RetransmitEventsEvent] interface as a parameter.
                * - Handle the returned promise (recommended).
                * Rejects to a [Messaging.MessengerError] if  more than 100 events are requested.
                * @param eventsFrom First event in sequence range, inclusive
                * @param eventsTo Last event in sequence range, inclusive
                * @returns {Promise<EventHandlers.RetransmitEventsEvent>|Promise}
                */
            retransmitEvents(eventsFrom: number, eventsTo: number): Promise<Messaging.EventHandlers.RetransmitEventsEvent>;
            /**
                * Request a number of events starting with the specified sequence to be sent from the cloud to this client.
                * Only [MessengerEvents.CreateConversation], [MessengerEvents.EditConversation], [MessengerEvents.SendMessage] and [MessengerEvents.EditMessage] events can be retransmitted; any other events cannot.
                * The method is used to get history or missed events in case of network disconnect.
                * Client should use this method to request all events based on the last conversation event sequence received from the cloud and last event sequence saved locally (if any).
                * If the current user quits an uber conversation (see [Conversation.uberConversation]), messages that has been posted during the user's absence are not retransmitted later.
                * The maximum number for requested events per method call is 100.
                * Triggers multiple [MessengerEvents.RetransmitEvents] events (for each retransmitted event).
                * The result contains maximum available events for the current user even if it is less than the specified count value. To get the method call result use one of the following options:
                * - Subscribe to the [MessengerEvents.RetransmitEvents] event and provide a handler consuming an object with the [EventHandlers.RetransmitEventsEvent] interface as a parameter.
                * - Handle the returned promise (recommended).
                * Rejects to a [Messaging.MessengerError] if  more than 100 events are requested.
                * @param eventsFrom First event in sequence range, inclusive
                * @param count Number of events
                * @returns {Promise<EventHandlers.RetransmitEventsEvent>|Promise}
                */
            retransmitEventsFrom(eventsFrom: number, count: number): Promise<Messaging.EventHandlers.RetransmitEventsEvent>;
            /**
                * Requests a number of events up to the specified sequence to be sent from the cloud to this client.
                * Only [MessengerEvents.CreateConversation], [MessengerEvents.EditConversation], [MessengerEvents.SendMessage] and [MessengerEvents.EditMessage] events can be retransmitted; any other events cannot.
                * The method is used to get history or missed events in case of network disconnect.
                * Client should use this method to request all events based on the last conversation event sequence received from the cloud and last event sequence saved locally (if any).
                * If the current user quits an uber conversation (see [Conversation.uberConversation]), messages that has been posted during the user's absence are not retransmitted later.
                * The maximum number for requested events per method call is 100.
                * Triggers multiple [MessengerEvents.RetransmitEvents] events (for each retransmitted event).
                * The result contains maximum available events for the current user even if it is less than the specified count value. To get the method call result use one of the following options:
                * - Subscribe to the [MessengerEvents.RetransmitEvents] event and provide a handler consuming an object with the [EventHandlers.RetransmitEventsEvent] interface as a parameter.
                * - Handle the returned promise (recommended).
                * Rejects to a [Messaging.MessengerError] if  more than 100 events are requested.
                * @param eventsTo Last event in sequence range, inclusive
                * @param count Number of events
                * @returns {Promise<EventHandlers.RetransmitEventsEvent>|Promise}
                */
            retransmitEventsTo(eventsTo: number, count: number): Promise<Messaging.EventHandlers.RetransmitEventsEvent>;
            /**
                * @hidden
                * @return {string}
                * @private
                */
            _traceName(): string;
    }
}

declare module 'voximplant-websdk/Messaging/src/Message' {
    import { Conversation } from 'voximplant-websdk/Messaging/src/Conversation';
    import { MsgInput, MsgOutput, SerializedMessage } from 'voximplant-websdk/Messaging/src/Structures';
    import Messaging from 'voximplant-websdk/Messaging';
    /**
        * @hidden
        */
    export class Message {
            /**
                * The universally unique identifier (UUID) of the message. Can be used on client side for housekeeping.
                * @returns {string}
                */
            get uuid(): string;
            /**
                * The UUID of the conversation this message belongs to.
                */
            get conversation(): string;
            /**
                * Message text.
                */
            get text(): string;
            /**
                * Setting this property does not send changes to the cloud.
                * Use the [Message.update] method to send all the changes at once.
                * @param value {string}
                */
            set text(value: string);
            /**
                * Array of payload objects associated with the message.
                */
            get payload(): Array<Object>;
            /**
                * Setting this property does not send changes to the cloud.
                * Use the [Message.update] method to send all the changes at once.
                * @param value {Array<object>}
                */
            set payload(value: Array<Object>);
            /**
                * The id of the user who sent this message (see [ConversationParticipant.userId]).
                */
            get sender(): number;
            /**
                * @hidden
                * @param {string} message
                * @param {Array<object>} payload
                */
            constructor(message: string, payload?: Array<Object>);
            /**
                * @hidden
                * @param busMessage
                * @param seq
                */
            static _createFromBus(busMessage: MsgOutput.Message, sender: number): Message;
            /**
                * @hidden
                * @param cacheMessage
                * @returns {Message}
                */
            static createFromCache(cacheMessage: SerializedMessage): Message;
            /**
                * Serialize the message so it can be stored (e.g. in IndexedDB) and later restored via the [Messenger2.createMessageFromCache] method
                */
            toCache(): SerializedMessage;
            /**
                * @hidden
                * @returns {{text: string, conversation: string, payload?: object[]}}
                */
            getPayload(): MsgInput.SendMessage;
            /**
                * @hidden
                * @param conversation
                * @returns {Promise<EventHandlers.SendMessageEvent>|Promise}
                */
            sendTo(conversation: Conversation): Promise<Messaging.EventHandlers.SendMessageEvent>;
            /**
                * Send text and payload changes to the cloud.
                * Triggers the [MessengerEvents.EditMessage] event for all parties of the conversation (online participants and logged in clients).
                * To get the result, use one of these options:
                * - Subscribe to the [MessengerEvents.EditMessage] event and provide a handler consuming an object with the [EventHandlers.EditMessageEvent] interface as a parameter.
                * Remember that [MessengerEvents.EditMessage] may be triggered by another user, so check the 'initiator' field.
                * - Handle the returned promise. Though you still need to listen to [MessengerEvents.EditMessage] event to handle events from other parties.
                * Rejects to a [Messaging.MessengerError] if
                * - the current user cannot edit own messages (see [ConversationParticipant.canEdit] and [ConversationParticipant.isOwner]),
                * - the current user cannot edit other partisipants' messages (see [ConversationParticipant.canEditAll] and [ConversationParticipant.isOwner]).
                * @returns {Promise<EventHandlers.EditMessageEvent>|Promise}
                */
            update(): Promise<Messaging.EventHandlers.EditMessageEvent>;
            /**
                * Remove the message from the conversation.
                * Triggers the [MessengerEvents.RemoveMessage] event for all parties of the conversation (online participants and logged in clients).
                * To get the result, use one of these options:
                * - Subscribe to the [MessengerEvents.RemoveMessage] event and provide a handler consuming an object with the [EventHandlers.RemoveMessageEvent] interface as a parameter.
                * Remember that [MessengerEvents.RemoveMessage] may be triggered by another user, so check the 'initiator' field.
                * - Handle the returned promise. Though you still need to listen to [MessengerEvents.RemoveMessage] event to handle events from other parties.
                * Rejects to a [Messaging.MessengerError] if
                * - the current user cannot remove own messages (see [ConversationParticipant.canRemove] and [ConversationParticipant.isOwner]),
                * - the current user cannot remove other partisipants' messages (see [ConversationParticipant.canRemoveAll] and [ConversationParticipant.isOwner]).
                * @returns {Promise<EventHandlers.RemoveMessageEvent>|Promise}
                */
            remove(): Promise<Messaging.EventHandlers.RemoveMessageEvent>;
            /**
                * @hidden
                * @return {string}
                * @private
                */
            _traceName(): string;
    }
}

declare module 'voximplant-websdk/Messaging/src/Structures' {
    import { MsgEvent } from 'voximplant-websdk/Signaling/MsgEvent';
    import Messaging from 'voximplant-websdk/Messaging';
    import { MsgAction } from 'voximplant-websdk/Signaling/MsgAction';
    /**
        * IM gen 2
        * @hidden
        */
    export interface MsgActionToEvent {
            [MsgEvent.onError]: MsgAction;
            [MsgEvent.onCreateConversation]: MsgAction.createConversation;
            [MsgEvent.onEditConversation]: MsgAction.editConversation | MsgAction.joinConversation | MsgAction.leaveConversation | MsgAction.addParticipants | MsgAction.editParticipants | MsgAction.removeParticipants;
            [MsgEvent.onRemoveConversation]: MsgAction.removeConversation | MsgAction.removeEmptyConversation;
            [MsgEvent.onGetConversation]: MsgAction.getConversation | MsgAction.getConversations | MsgAction.searchConversations;
            [MsgEvent.onGetPublicConversations]: MsgAction.getPublicConversations;
            [MsgEvent.onGetUser]: MsgAction.getUser | MsgAction.getUsers;
            [MsgEvent.onEditUser]: MsgAction.editUser;
            [MsgEvent.onSetStatus]: MsgAction.setStatus;
            [MsgEvent.onSendMessage]: MsgAction.sendMessage;
            [MsgEvent.onEditMessage]: MsgAction.editMessage;
            [MsgEvent.onRemoveMessage]: MsgAction.removeMessage;
            [MsgEvent.isRead]: MsgAction.isRead;
            [MsgEvent.onTyping]: MsgAction.typingMessage;
            [MsgEvent.onSubscribe]: MsgAction.subscribe;
            [MsgEvent.onUnsubscribe]: MsgAction.unsubscribe;
            [MsgEvent.onGetSubscriptionList]: MsgAction.getSubscriptionList;
            [MsgEvent.onCreateBot]: MsgAction.createBot;
            [MsgEvent.onRemoveBot]: MsgAction.removeBot;
            [MsgEvent.onRetransmitEvents]: MsgAction.retransmitEvents;
    }
    /**
        * @hidden
        */
    export enum MsgService {
            Chat
    }
    /**
        * @hidden
        */
    export interface MsgInputMessage<E extends keyof MsgInputData | MsgAction> {
            service: MsgService;
            event: E;
            payload: MsgInPayload<E>;
            /**
                * Username.
                */
            from?: string;
            connid?: string;
            request_uuid: string;
    }
    /**
        * @hidden
        */
    export interface MsgOutputMessage<E extends MsgEvent> {
            service: MsgService;
            event: E;
            payload: MsgOutPayload<MsgActionToEvent[E]> | MsgErrorPayload;
            /**
                * Current user id
                */
            to: string;
            /**
                * All receiving user ids
                */
            toId: string[];
            connid: string;
            request_uuid: string;
            version: string;
    }
    /**
        * @hidden
        */
    export type MsgInPayload<E extends keyof MsgInputData> = MsgInputData[E] & {
            '@type': string;
    };
    /**
        * Payload received from IM API
        * @hidden
        */
    export interface MsgOutPayload<E extends MsgAction> {
            '@type': string;
            /**
                * Action author id.
                */
            initiator: number;
            on_incoming_event: E;
            object: MsgOutputData[E];
            /**
                * Optional. Only for conversation objects.
                */
            seq?: number;
            /**
                * Optional. Server's timestamp when then event is processing.
                */
            timestamp?: number;
            /**
                * Optional. Retransmit only.
                */
            from_seq?: number;
            /**
                * Optional. Retransmit only.
                */
            to_seq?: number;
            /**
                * Optional. Retransmit only.
                */
            count?: number;
    }
    /**
        * Error payload received from IM API
        * @hidden
        */
    export interface MsgErrorPayload {
            '@type': string;
            /**
                * Action author id.
                */
            initiator: number;
            on_incoming_event: MsgAction;
            code: number;
            description: string;
            timestamp?: number;
    }
    /**
        * Namespace for for IM API both request or response events.
        * @hidden
        */
    export namespace MsgInOutput {
            interface PresenceMessage {
                    /**
                        * Whether the user is online. Can be set by the [Messenger.setStatus] method.
                        */
                    online: boolean;
            }
            interface TypingMessage {
                    conversation: string;
            }
            interface StatusMessage {
                    conversation: string;
                    seq: number;
                    status?: string;
            }
            /**
                * Use to subscribe and unsubscribe.
                */
            interface ManageSubscribes {
                    user_id?: number[];
                    /**
                        * Optional. Only to unsubscribe.
                        */
                    all?: boolean;
            }
    }
    /**
        * Namespace for IM API request events.
        * @hidden
        */
    export namespace MsgInput {
            interface EditConversation {
                    uuid: string;
                    /**
                        * Title of conversation.
                        */
                    title: string;
                    /**
                        * Optional. Whether to enable the public join. The default value is false.
                        */
                    enable_public_join?: boolean;
                    /**
                        * Optional. Any JSON object.
                        */
                    custom_data?: object;
            }
            interface CreateConversation {
                    /**
                        * Title of conversation.
                        */
                    title: string;
                    /**
                        * Optional. Whether the conversation is direct. The default value is false.
                        */
                    direct?: boolean;
                    /**
                        * Optional. Whether to enable the public join. The default value is false.
                        */
                    enable_public_join?: boolean;
                    /**
                        * Optional. Whether the conversation is uber. The default value is false.
                        */
                    uber_conversation?: boolean;
                    /**
                        * Optional. Any JSON object.
                        */
                    custom_data?: object;
                    participants: MsgParticipant[];
            }
            interface RemoveConversation {
                    uuid: string;
            }
            interface JoinConversation {
                    uuid: string;
            }
            interface LeaveConversation {
                    uuid: string;
            }
            /**
                * Use to add or edit participants.
                */
            interface ManageParticipants {
                    uuid: string;
                    participants: MsgParticipant[];
            }
            /**
                * Use to remove participants.
                */
            interface RemoveParticipants {
                    uuid: string;
                    /**
                        * Array of [Messaging.MsgParticipant.user_id].
                        */
                    participants: number[];
            }
            interface GetConversation {
                    uuid: string;
            }
            interface GetConversations {
                    /**
                        * Array of conversation uuids.
                        */
                    uuid: string[];
            }
            interface GetPublicConversations {
            }
            interface SearchConversations {
                    uuid?: string[];
                    title?: string[];
                    enable_public_join?: boolean;
                    count?: number;
                    offset?: number;
            }
            interface SendMessage {
                    /**
                        * Conversation uuid.
                        */
                    conversation: string;
                    /**
                        * Optional. Message text.
                        */
                    text?: string;
                    /**
                        * Optional. Message payload.
                        */
                    payload?: object[];
            }
            interface EditMessage {
                    /**
                        * Message uuid.
                        */
                    uuid: string;
                    /**
                        * Conversation uuid.
                        */
                    conversation: string;
                    /**
                        * Optional. Message text.
                        */
                    text?: string;
                    /**
                        * Optional. Message payload.
                        */
                    payload?: object[];
            }
            interface RemoveMessage {
                    /**
                        * Message uuid.
                        */
                    uuid: string;
                    /**
                        * Conversation uuid.
                        */
                    conversation: string;
            }
            interface RetransmitRequest {
                    conversation: string;
                    events_from?: number;
                    events_to?: number;
                    count?: number;
            }
            interface GetUser {
                    user_id?: number;
                    user_name?: string;
            }
            interface GetUsers {
                    users: Partial<MsgUserInfo>[];
            }
            interface EditUser {
                    /**
                        * Optional. Visible only for the current and parent accounts.
                        */
                    custom_data?: object;
                    /**
                        * Optional. Visible only for the user.
                        */
                    private_custom_data?: object;
            }
            interface CreateBot {
                    user_name: string;
                    /**
                        * Optional. Visible only for the current and parent accounts.
                        */
                    custom_data?: object;
            }
            interface RemoveBot {
                    user_id: number;
            }
            interface ManageNotifications {
                    notifications: MsgEvent[];
            }
            interface GetSubscriptionList {
            }
    }
    /**
        * Namespace for IM API response events.
        * @hidden
        */
    export namespace MsgOutput {
            interface Conversation {
                    uuid: string;
                    /**
                        * Title of conversation.
                        */
                    title: string;
                    participants: MsgParticipant[];
                    /**
                        * Optional. Whether the conversation is direct. The default value is false.
                        */
                    direct?: boolean;
                    /**
                        * Optional. Whether to enable the public join. The default value is false.
                        */
                    enable_public_join?: boolean;
                    /**
                        * Optional. Whether the conversation is public. The default value is false.
                        */
                    uber_conversation?: boolean;
                    /**
                        * Optional. Any JSON object.
                        */
                    custom_data?: object;
                    /**
                        * Optional. Creation date. Only for responses.
                        */
                    created_at?: number;
                    /**
                        * Optional. Only for responses.
                        */
                    last_update?: number;
            }
            interface PublicConversations {
                    /**
                        * Array of conversation uuids.
                        */
                    uuid: string[];
            }
            interface Message {
                    /**
                        * Message uuid.
                        */
                    uuid: string;
                    /**
                        * Conversation uuid.
                        */
                    conversation: string;
                    /**
                        * Optional. Message text.
                        */
                    text?: string;
                    /**
                        * Optional. Message payload.
                        */
                    payload?: object[];
            }
            interface UserData {
                    user_id: number;
                    user_name: string;
                    display_name: string;
                    /**
                        * Optional. Visible only for the current and parent accounts.
                        */
                    custom_data?: object;
                    /**
                        * Optional. Visible only for the user.
                        */
                    private_custom_data?: object;
                    /**
                        * Optional. Visible only for the user.
                        */
                    notification_events?: MsgEvent[];
                    /**
                        * Optional. Visible only for the user.
                        */
                    conversations_list?: string[];
                    /**
                        * Optional. Visible only for the user.
                        */
                    leave_conversations?: string[];
                    deleted: boolean;
            }
            interface UserSubscriptions {
                    /**
                        * Array of Messaging user ids the user is subscribed to.
                        */
                    subscriptions: Array<number>;
            }
    }
    /**
        * @hidden
        */
    export interface MsgUserInfo {
            user_id: number;
            user_name: string;
    }
    /**
        * @hidden
        */
    export enum MsgPermissions {
            none = 0,
            can_write = 1,
            can_edit = 2,
            can_remove = 4,
            can_manage_participants = 8,
            can_edit_all = 16,
            can_remove_all = 32,
            is_owner = 32768,
            all = 65535
    }
    /**
        * @hidden
        */
    export interface MsgParticipant {
            user_id: number;
            flags: number;
            /**
                * Only in response.
                */
            last_read?: number;
    }
    /**
        * @hidden
        */
    export interface MsgInputData {
            /**
                * @hidden
                */
            UNKNOWN: any;
            createConversation: MsgInput.CreateConversation;
            editConversation: MsgInput.EditConversation;
            removeConversation: MsgInput.RemoveConversation;
            addParticipants: MsgInput.ManageParticipants;
            editParticipants: MsgInput.ManageParticipants;
            removeParticipants: MsgInput.RemoveParticipants;
            leaveConversation: MsgInput.LeaveConversation;
            joinConversation: MsgInput.JoinConversation;
            getConversation: MsgInput.GetConversation;
            getConversations: MsgInput.GetConversations;
            getPublicConversations: MsgInput.GetPublicConversations;
            /**
                * @hidden
                */
            searchConversations: MsgInput.SearchConversations;
            /**
                * @hidden
                */
            removeEmptyConversation: MsgInput.RemoveConversation;
            sendMessage: MsgInput.SendMessage;
            editMessage: MsgInput.EditMessage;
            removeMessage: MsgInput.RemoveMessage;
            retransmitEvents: MsgInput.RetransmitRequest;
            getUser: MsgInput.GetUser;
            getUsers: MsgInput.GetUsers;
            editUser: MsgInput.EditUser;
            manageNotification: MsgInput.ManageNotifications;
            subscribe: MsgInOutput.ManageSubscribes;
            unsubscribe: MsgInOutput.ManageSubscribes;
            getSubscriptionList: MsgInput.GetSubscriptionList;
            typingMessage: MsgInOutput.TypingMessage;
            isRead: MsgInOutput.StatusMessage;
            setStatus: MsgInOutput.PresenceMessage;
            /**
                * @hidden
                */
            createBot: MsgInput.CreateBot;
            /**
                * @hidden
                */
            removeBot: MsgInput.RemoveBot;
    }
    /**
        * @hidden
        */
    export interface MsgOutputData {
            /**
                * @hidden
                */
            UNKNOWN: any;
            createConversation: MsgOutput.Conversation;
            editConversation: MsgOutput.Conversation;
            removeConversation: MsgOutput.Conversation;
            joinConversation: MsgOutput.Conversation;
            leaveConversation: MsgOutput.Conversation;
            getConversation: MsgOutput.Conversation;
            getConversations: MsgOutput.Conversation[];
            getPublicConversations: MsgOutput.PublicConversations;
            /**
                * @hidden
                */
            searchConversations: MsgOutput.Conversation;
            /**
                * @hidden
                */
            removeEmptyConversation: MsgOutput.Conversation;
            addParticipants: MsgOutput.Conversation;
            editParticipants: MsgOutput.Conversation;
            removeParticipants: MsgOutput.Conversation;
            getUser: MsgOutput.UserData;
            getUsers: MsgOutput.UserData;
            editUser: MsgOutput.UserData;
            setStatus: MsgInOutput.PresenceMessage;
            sendMessage: MsgOutput.Message;
            editMessage: MsgOutput.Message;
            /**
                * Returns [Messaging.MsgOutput.Message] with uuid and conversation only
                */
            removeMessage: MsgOutput.Message;
            typingMessage: MsgInOutput.TypingMessage;
            isRead: MsgInOutput.StatusMessage;
            subscribe: MsgInOutput.ManageSubscribes;
            unsubscribe: MsgInOutput.ManageSubscribes;
            manageNotification: MsgOutput.UserData;
            getSubscriptionList: MsgOutput.UserSubscriptions;
            /**
                * @hidden
                */
            createBot: MsgOutput.UserData;
            /**
                * @hidden
                */
            removeBot: {};
            retransmitEvents: MsgOutputMessage<MsgEvent>;
    }
    /**
        * @hidden
        * */
    export interface SerializedMessage {
            /**
                * See [Message.uuid].
                */
            uuid: string;
            /**
                * See [Message.text].
                */
            text: string;
            /**
                * See [Message.payload].
                */
            payload: Array<object>;
            /**
                * See [Message.conversation].
                */
            conversation: string;
            /**
                * See [Message.sender].
                */
            sender: number;
    }
    /**
        * @hidden
        */
    export interface SerializedConversation {
            /**
                * See [Conversation.uuid].
                */
            uuid: string;
            /**
                * See [Conversation.title].
                */
            title: string;
            /**
                * See [Conversation.createdAt].
                */
            createdAt: number;
            /**
                * See [Conversation.lastUpdate].
                */
            lastUpdate: number;
            /**
                * See [Conversation.direct].
                */
            direct: boolean;
            /**
                * See [Conversation.publicJoin].
                */
            publicJoin: boolean;
            /**
                * See [Conversation.uberConversation].
                */
            uberConversation: boolean;
            /**
                * See [Conversation.lastSeq].
                */
            lastSeq: number;
            /**
                * See [Conversation.participants].
                */
            participants: Array<ConversationParticipant>;
            /**
                * See [Conversation.customData].
                */
            customData: Object;
    }
    /**
        * @hidden
        */
    export interface ConversationParticipant {
            /**
                * Messaging user id.
                */
            userId: number;
            /**
                * Optional. Whether a user is an owner of the conversation. There can be more than one owner in the conversation.
                * An owner can edit the conversation and has all other permissions.
                */
            isOwner?: boolean;
            /**
                * Optional. Whether a user can write messages in the conversation. The permission is given by default.
                * Could be changed only by the user that has the [ConversationParticipant.canManageParticipants] or the [ConversationParticipant.isOwner] permission.
                */
            canWrite?: boolean;
            /**
                * Optional. Whether a user can edit own messages in the conversation. The permission is given by default.
                * Could be changed only by the user that has the [ConversationParticipant.canManageParticipants] or the [ConversationParticipant.isOwner] permission.
                */
            canEdit?: boolean;
            /**
                * Optional. Whether a user can remove own messages in the conversation. The permission is given by default.
                * Could be changed only by the user that has the [ConversationParticipant.canManageParticipants] or the [ConversationParticipant.isOwner] permission.
                */
            canRemove?: boolean;
            /**
                * Optional. Whether a user can manage conversation participants: edit permissions and add/remove participants.
                * Could be changed only by the user that has the [ConversationParticipant.canManageParticipants] or the [ConversationParticipant.isOwner] permission.
                */
            canManageParticipants?: boolean;
            /**
                * Optional. Whether a user can edit other users' messages in the conversation.
                * Could be changed only by the user that has the [ConversationParticipant.canManageParticipants] or the [ConversationParticipant.isOwner] permission.
                */
            canEditAll?: boolean;
            /**
                * Optional. Whether a user can remove other users' messages in the conversation.
                * Could be changed only by the user that has the [ConversationParticipant.canManageParticipants] or the [ConversationParticipant.isOwner] permission.
                */
            canRemoveAll?: boolean;
            /**
                * Optional. The sequence of the message event that is marked as last read by this user in the conversation.
                * Participants mark events as read via [Conversation.markAsRead].
                * Is '0' if the participant has not marked any event as read.
                */
            lastRead?: number;
    }
    /**
        * @hidden
        */
    export interface User {
            /**
                * Messaging user id. Use to identify users only within the Messaging module.
                */
            userId: number;
            /**
                * The Voximplant user identifier (e.g. 'username@appname.accname').
                */
            userName: string;
            /**
                * The user's display name specified in [Voximplant control panel](https://manage.voximplant.com) or via [HTTP API](/docs/references/httpapi).
                */
            displayName: string;
            /**
                * @hidden
                * Optional. Whether the user is deleted.
                */
            deleted?: boolean;
            /**
                * Array of conversation UUIDs the current user belongs to.
                * Not available for all other users (undefined).
                */
            conversationsList: Array<string> | undefined;
            /**
                * @hidden
                * Optional. List of UUIDs for the conversations the user has left. Only available if user queries information about themselves.
                */
            leaveConversationList?: Array<string>;
            /**
                * Array of [MessengerEvents] the current user is subscribed to (when they occur, the user receives push notifications).
                * Not available for all other users (undefined).
                * The current user subscriptions can be set via the [Messenger.manageNotification] method.
                */
            notificationEvents: Array<Messaging.MessengerEvents> | undefined;
            /**
                * Public custom data available to all users. Can be set via [Messenger.editUser].
                */
            customData: Object;
            /**
                * Private custom data available only to the current user.
                * Undefined for all other users.
                */
            privateCustomData: Object | undefined;
    }
}

declare module 'voximplant-websdk/Call/EndpointListDescription' {
    /**
        * @hidden
        */
    export interface EndpointListDescription {
            endpoints: {
                    [id: string]: EndpointDescription;
            };
            reinviteCauses: ReinviteCause[];
    }
    /**
        * @hidden
        */
    export interface EndpointDescription {
            place: number;
            type: 'call' | 'player';
            mids: MidDescription;
    }
    /**
        * @hidden
        */
    export type MidDiff = {
            added: MidDescription;
            removed: MidDescription;
            changed: MidDescription;
            unchanged: MidDescription;
    };
    /**
        * @hidden
        */
    export interface ChangedEndpointDescription extends EndpointDescription {
            midDiff: MidDiff;
    }
    /**
        * @hidden
        */
    export type MidDescription = {
            [id: string]: EndpointMediaKind;
    };
    /**
        * @hidden
        */
    export type EndpointMediaKind = 'audio' | 'video' | 'sharing';
    /**
        * @hidden
        */
    export interface ReinviteCause {
            displayName?: string;
            event: string;
            id: string;
            place?: string;
            username?: string;
            sipURI?: string;
    }
    /**
        * @hidden
        */
    export interface EndpointInfoData {
            id: string;
            place: number;
            username: string;
            displayName: string;
            sipURI: string;
    }
}

declare module 'voximplant-websdk/Types' {
    import { Call } from 'voximplant-websdk/Call/Call';
    import { ViewerCall } from 'voximplant-websdk/Call/ViewerCall';
    /**
        * @hidden
        */
    export enum BrowserMode {
            Firefox = 0,
            Chrome = 1
    }
    /**
        * @hidden
        */
    export enum TrackType {
            audio,
            video,
            sharing
    }
    /**
        * Call related errors.
        * @hidden
        */
    export enum CallError {
            /**
                * The call is already in requested state
                */
            ALREADY_IN_THIS_STATE = 0,
            /**
                * Requested functionality is disabled
                */
            FUNCTIONALITY_IS_DISABLED = 1,
            /**
                * Operation is incorrect, f.ex.
                */
            INCORRECT_OPERATION = 2,
            /**
                * Internal error occurred
                */
            INTERNAL_ERROR = 3,
            /**
                * Operation cannot be performed due to the call is on hold.
                */
            MEDIA_IS_ON_HOLD = 4,
            /**
                * Operation is rejected
                */
            REJECTED = 5,
            /**
                * Operation is not completed in time
                */
            TIMEOUT = 6
    }
    /**
        * Extra options for custom PeerConnections
        * @hidden
        */
    export interface PCSetConfigurationOptions {
            call?: Call | ViewerCall;
    }
}

declare module 'voximplant-websdk/Hardware/src' {
    /**
        * @hidden
        */
    export { AudioDeviceManager } from 'voximplant-websdk/Hardware/src/AudioDeviceManager';
    /**
        * @hidden
        */
    export { AudioParams } from 'voximplant-websdk/Hardware/src/AudioParams';
    /**
        * @hidden
        */
    export { CameraManager } from 'voximplant-websdk/Hardware/src/CameraManager';
    /**
        * @hidden
        */
    export { CameraParams } from 'voximplant-websdk/Hardware/src/CameraParams';
    /**
        * @hidden
        */
    export { SharingStream } from 'voximplant-websdk/Hardware/src/SharingStream';
    /**
        * @hidden
        */
    export { StreamManager } from 'voximplant-websdk/Hardware/src/StreamManager';
}

declare module 'voximplant-websdk/Call/SimpleCall' {
    import { CallState } from 'voximplant-websdk/Call/AbstractCall';
    import { Endpoint } from 'voximplant-websdk/Call/EndPoints/Endpoint';
    /**
        * @hidden
        */
    export interface SimpleCall {
            /**
                * Returns call id
                */
            id(): string;
            /**
                * Returns display name, i.e. a name of the calling user, that is displayed to the called user. Normally it is a human-readable version of CallerID, e.g. a person's name.
                */
            displayName(): string;
            /**
                * Returns dialed number or caller id
                */
            number(): string;
            /**
                * Get the call duration
                * @return the call duration in milliseconds
                */
            getCallDuration(): number;
            /**
                * Get all current [Endpoint]s in the call.
                * @returns {Endpoint[]}
                */
            getEndpoints(): Endpoint[];
            /**
                * Get the current state of a call.
                * Possible values are: "ALERTING", "PROGRESSING", "CONNECTED", "ENDED".
                */
            state(): CallState;
            /**
                * Hangup call
                * @param {[id:string]:string} extraHeaders Optional custom parameters (SIP headers) that should be sent after disconnecting/cancelling call. Parameter names should start with "X-" to be processed by application
                */
            hangup(extraHeaders?: {
                    [id: string]: string;
            }): any;
            /**
                * Send text message. It is a special case of the [sendInfo] method as it allows to send messages only of "text/plain" type.
                *
                * You can get this message via the Voxengine [CallEvents.MessageReceived] event in our cloud.
                *
                * You can get this message in Web SDK on other side via the [CallEvents.MessageReceived] event; see the similar events for the <a href="/docs/references/iossdk/call/vicalldelegate#calldidreceivemessageheaders">iOS</a> and <a href="/docs/references/androidsdk/call/icalllistener#onmessagereceived">Android</a> SDKs.
                * @param {string} msg Message text
                */
            sendMessage(msg: string): void;
    }
}

declare module 'voximplant-websdk/PeerConnection/PeerConnection' {
    import { Logger } from 'voximplant-websdk/Logger';
    import { Call } from 'voximplant-websdk/Call/Call';
    import { VideoFlags } from 'voximplant-websdk/Structures';
    import { PCSetConfigurationOptions, TrackType } from 'voximplant-websdk/Types';
    import { ReInviteQ } from 'voximplant-websdk/PeerConnection/ReInviteQ';
    import { EventHandlers } from 'voximplant-websdk/EventHandlers';
    import { CandidateString, LineIndex } from 'voximplant-websdk/typings/peerConnection';
    /**
        * @hidden
        */
    export enum PeerConnectionState {
            IDLE = 0,
            REMOTEOFFER = 1,
            LOCALOFFER = 2,
            ESTABLISHING = 3,
            ESTABLISHED = 4,
            CLOSED = 5
    }
    /**
        * @hidden
        */
    export enum PeerConnectionMode {
            CLIENT_SERVER_V1 = 0,
            P2P = 1,
            CONFERENCE = 2
    }
    /**
        * Peer connection wrapper. Will have implementations for WebRTC/ORTC
        * @hidden
        */
    export abstract class PeerConnection {
            protected id: string;
            protected mode: PeerConnectionMode;
            protected videoEnabled: VideoFlags;
            protected _localStream: MediaStream;
            protected logger: Logger;
            protected state: PeerConnectionState;
            protected _call: Call;
            protected pendingCandidates: [LineIndex, CandidateString][];
            protected canSendCandidates: boolean;
            protected reInviteQ: ReInviteQ;
            protected sinkId: any;
            /**
                * @hidden
                * @param state
                */
            protected onHold: boolean;
            protected _canReInvite: {
                    (): boolean;
            };
            protected muteMicState: boolean;
            protected renegotiationInProgress: boolean;
            protected abstract manageLayers(layers: string[]): void;
            constructor(id: string, mode: PeerConnectionMode, videoEnabled: VideoFlags);
            protected _remoteStreams: Array<MediaStream>;
            get remoteStreams(): MediaStream[];
            abstract _hdnFRSPrep(): void;
            abstract hasLocalAudio(): boolean;
            abstract enableVideo(flag: boolean): void;
            abstract replaceVideoOrSharingConferenceSimulcast(stream: MediaStream, streamType: string): Promise<void>;
            abstract getTransceivers(): RTCRtpTransceiver[];
            abstract getRemoteDescription(): string;
            abstract _fixFFSoundBug(): void;
            abstract updateHoldState(): void;
            getId(): string;
            getState(): PeerConnectionState;
            processRemoteAnswer(headers: {
                    [id: string]: string;
            }, sdp: string): Promise<void>;
            getLocalOffer(): Promise<RTCSessionDescription>;
            getLocalAnswer(): Promise<RTCSessionDescription>;
            processRemoteOffer(sdp: string): Promise<string>;
            close(): void;
            addRemoteCandidate(candidate: string, mLineIndex: number): Promise<void>;
            handleReinvite(headers: {
                    [id: string]: string;
            }, sdp: string, hasVideo: boolean): Promise<void>;
            handleRemoteOffer(headers: {
                    [id: string]: string;
            }, sdp: string, hasVideo: boolean): Promise<void>;
            addCandidateToSend(attrString: CandidateString, mLineIndex: LineIndex): void;
            canStartSendingCandidates(): void;
            sendDTMF(key: string): void;
            setVideoEnabled(newVal: VideoFlags): void;
            setVideoFlags(newFlags: VideoFlags): void;
            /**
                * Get sdp audio/video directions from sdp
                * @hidden
                */
            getDirections(): Object;
            /**
                * @hidden
                * @param state
                */
            setHoldKey(state: any): void;
            getMidKinds(): {
                    [id: string]: TrackType;
            };
            getTrackKind(sdp: string): {
                    [id: string]: TrackType;
            };
            sendMedia(audio: boolean, video: boolean): Promise<EventHandlers.Updated>;
            /**
                * Hold/Unhold action for protocol v3 (Fully implement RFC 4566
                * @param newState
                */
            hold(newState: boolean): Promise<EventHandlers.Updated>;
            hdnFRS(): Promise<EventHandlers.Updated>;
            abstract _hdnFRS(): void;
            getMicrophoneState(): boolean;
            muteMicrophone(newState: boolean): void;
            restoreMute(): void;
            restoreVideoSending(): void;
            addCustomMedia(stream: MediaStream): Promise<void>;
            /**
                * @hidden
                * @param {MediaStream} stream
                */
            fastAddCustomMedia(stream: MediaStream): void;
            /**
                * @hidden
                * @param {MediaStream} stream
                */
            fastRemoveCustomMedia(stream: MediaStream): void;
            removeCustomMedia(stream: MediaStream): Promise<void>;
            /**
                * @hidden
                * @param {MediaStream} stream
                */
            updateMediaTracks(stream: MediaStream): void;
            /**
                * @param {MediaStream} stream
                */
            updateCustomMedia(stream: MediaStream): void;
            /**
                * @hidden
                * @param {MediaStreamTrack} track
                */
            replaceSharingToVideo(track: MediaStreamTrack, typeNewTrack: string): Promise<void>;
            protected abstract _replaceSharingToVideo(track: MediaStreamTrack, typeNewTrack: string): Promise<void>;
            abstract getConfiguration(): RTCConfiguration;
            abstract setConfiguration(config: RTCConfiguration, options?: PCSetConfigurationOptions): any;
            /**
                * @hidden
                * @param transceiver
                * @param newEncodings
                */
            setEncodingsParams(transceiver: RTCRtpTransceiver, newEncodings: RTCRtpEncodingParameters[]): void;
            protected abstract _setEncodingsParams(transceiver: RTCRtpTransceiver, newEncodings: RTCRtpEncodingParameters[]): void;
            /**
                * @hidden
                * @return {string}
                * @private
                */
            _traceName(): string;
            protected abstract _processRemoteAnswer(headers: {
                    [id: string]: string;
            }, sdp: string): Promise<void>;
            protected abstract _getLocalOffer(): Promise<RTCSessionDescription>;
            protected abstract _getLocalAnswer(): Promise<RTCSessionDescription>;
            protected abstract _processRemoteOffer(sdp: string): Promise<string>;
            protected abstract _close(): any;
            protected abstract _addRemoteCandidate(candidate: string, mLineIndex: number): Promise<void>;
            protected abstract _sendDTMF(key: string, duration: number, gap: number): void;
            protected abstract _getDirections(): Object;
            protected abstract _handleRemoteOffer(headers: {
                    [id: string]: string;
            }, sdp: string, hasVideo: boolean): Promise<void>;
            protected abstract _handleReinvite(headers: {
                    [id: string]: string;
            }, sdp: string, hasVideo: boolean): Promise<void>;
            protected setState(st: PeerConnectionState): void;
            protected abstract _hold(newState: boolean): void;
            protected abstract _addCustomMedia(stream: MediaStream): void;
            protected abstract _removeCustomMedia(stream: MediaStream): void;
            protected abstract _updateCustomMedia(stream: MediaStream): void;
            abstract updateSenderTrackTransformers(): void;
            abstract revertEnablingVideo(): void;
    }
}

declare module 'voximplant-websdk/Stats/v5/StatsReport' {
    interface ConnectionStatsReport {
            /**
                * The UNIX timestamp
                */
            timestamp: number;
            /**
                * Remote connection type
                */
            remoteType: 'host' | 'srflx' | 'relay';
            /**
                * Optional. Remote connection IP address
                */
            remoteIp?: string;
            /**
                * Remote connection protocol
                */
            remoteProtocol: 'udp' | 'tcp';
            /**
                * Remote connection port
                */
            remotePort: number;
            /**
                * Local connection type
                */
            localType: 'host' | 'srflx' | 'relay';
            /**
                * Optional. Local connection IP address
                */
            localIp?: string;
            /**
                * Local connection protocol
                */
            localProtocol: 'udp' | 'tcp';
            /**
                * Local connection port
                */
            localPort: number;
            /**
                * Number of bytes sent
                */
            bytesSent: number;
            /**
                * Number of bytes received
                */
            bytesReceived: number;
            /**
                * Optional. Available bitrate for all the outgoing RTP streams using this candidate pair
                */
            availableOutgoingBitrate?: number;
            /**
                * Sum of all round trip time measurements in seconds since the beginning of the session
                */
            rtt: number;
            /**
                * Optional. Latest round trip time measured in seconds
                */
            currentRtt?: number;
    }
    /**
        * @hidden
        */
    interface BaseOutboundStatsReport {
            /**
                * The UNIX timestamp
                */
            timestamp: number;
            /**
                * Number of bytes sent
                */
            bytesSent: number;
            /**
                * Number of packets sent
                */
            packetsSent: number;
            /**
                * Optional. If rid is set, this value is present regardless if the RID RTP header extension has been negotiated
                */
            rid?: string;
            /**
                * Packet jitter in seconds
                */
            jitter: number;
            /**
                * Sum of all round trip time measurements in seconds since the beginning of the session
                */
            rtt: number;
            /**
                * Number of packets lost
                */
            packetsLost: number;
            /**
                * Lost packets ratio
                */
            loss: number;
            /**
                * Optional. Codec name
                */
            codec?: string;
            /**
                * Optional. Payload type as used in RTP encoding or decoding
                */
            pt?: number;
            /**
                * Optional. Cumulative sum of all round trip time measurements in seconds since the beginning of the session
                */
            totalRtt?: number;
            /**
                * Bitrate in kbps
                */
            bitrate: number;
    }
    interface OutboundAudioStatsReport extends BaseOutboundStatsReport {
            kind: 'audio';
            /**
                * Optional. Outgoing audio level
                */
            audioLevel?: number;
            /**
                * Optional. Outgoing audio energy
                */
            totalAudioEnergy?: number;
    }
    interface OutboundVideoStatsReport extends BaseOutboundStatsReport {
            kind: 'video';
            /**
                * Total number of Full Intra Request (FIR) packets sent by this receiver
                */
            firCount: number;
            /**
                * Total number of Picture Loss Indication (PLI) packets sent by this receiver
                */
            pliCount: number;
            /**
                * Total number of Negative ACKnowledgement (NACK) packets sent by this receiver
                */
            nackCount: number;
            /**
                * Optional. Video frame width
                */
            width?: number;
            /**
                * Optional. Original video width
                */
            baseWidth?: number;
            /**
                * Optional. Video frame height
                */
            height?: number;
            /**
                * Optional. Original video height
                */
            baseHeight?: number;
            /**
                * Optional. Number of frames per second
                */
            framesPerSecond?: number;
            /**
                * Optional. Number of base frames per second
                */
            baseFramesPerSecond?: number;
            /**
                * Optional. Reason for quality limitation
                */
            qualityLimitationReason?: 'cpu' | 'bandwidth' | 'other' | 'none';
            /**
                * Optional. The number of times that the resolution has changed because of quality limitation
                */
            qualityLimitationResolutionChanges?: number;
            /**
                * Optional. The sum of the QP values of frames decoded by this receiver
                */
            qpSum?: number;
            /**
                * Optional. Total number of frames successfully encoded for this RTP media stream
                */
            framesEncoded?: number;
            /**
                * Optional. Total number of key frames, such as key frames in VP8 or IDR-frames in H.264, successfully encoded for this RTP media stream
                */
            keyFramesEncoded?: number;
    }
    /**
        * @hidden
        */
    type ReportKind = 'audio' | 'video';
    /**
        * @hidden
        */
    interface BasicInboundStatsReport {
            /**
                * The UNIX timestamp
                */
            timestamp: number;
            /**
                * Media kind: audio or video
                */
            kind: ReportKind;
            /**
                * Number of bytes received
                */
            bytesReceived: number;
            /**
                * Number of packets received
                */
            packetsReceived: number;
            /**
                * Number of packets lost
                */
            packetsLost: number;
            /**
                * Lost packets ratio
                */
            loss: number;
            /**
                * Packet jitter in seconds
                */
            jitter: number;
            /**
                * Bitrate in kbps
                */
            bitrate: number;
            /**
                * Optional. Endpoint name
                */
            endpoint?: string;
            /**
                * Optional. Codec name
                */
            codec?: string;
            /**
                * Optional. Sum of all round trip time measurements in seconds since the beginning of the session
                */
            rtt?: number;
            /**
                * Optional. Latest round trip time measured in seconds
                */
            totalRtt?: number;
    }
    interface InboundAudioStatsReport extends BasicInboundStatsReport {
            /**
                * Optional. Incoming audio level
                */
            audioLevel?: number;
            /**
                * Optional. Incoming audio energy
                */
            totalAudioEnergy?: number;
            /**
                * Optional. Total number of audio samples received
                */
            totalSamplesReceived?: number;
            /**
                * Optional. Total duration of audio samples received
                */
            totalSamplesDuration?: number;
            /**
                * Optional. When playout is slowed down, this counter increases by the difference between the number of samples received and the number of samples played out. If playout is slowed down by inserting samples, this is the number of inserted samples.
                */
            insertedSamplesForDeceleration?: number;
            /**
                * Optional. The total number of concealed samples inserted that are "silent". Playing out silent samples results in silence or comfort noise.
                */
            silentConcealedSamples?: number;
    }
    interface InboundVideoStatsReport extends BasicInboundStatsReport {
            /**
                * Optional. Video height in pixels
                */
            height?: number;
            /**
                * Optional. Video width in pixels
                */
            width?: number;
            /**
                * Optional. Video frames received
                */
            framesReceived?: number;
            /**
                * Optional. Video frames decoded
                */
            framesDecoded?: number;
            /**
                * Optional. Video frames skipped
                */
            framesDropped?: number;
            /**
                * Optional. Number of video frames per second
                */
            framesPerSecond?: number;
            /**
                * Optional. Total number of video freezes experienced by the receiver
                */
            freezeCount?: number;
            /**
                * Optional. Total number of video pauses experienced by the receiver
                */
            pauseCount?: number;
            /**
                * Optional. Total duration of frames
                */
            totalFramesDuration?: number;
            /**
                * Optional. Duration of rendered frames which are considered as frozen
                */
            totalFreezesDuration?: number;
            /**
                * Optional. Duration of rendered frames which are considered as paused
                */
            totalPausesDuration?: number;
    }
    interface MosReport {
            /**
                * Average MOS value for incoming and outgoing audio streams. Calculated based on E-Model (G.107).
                */
            mosG107: number;
    }
    interface StatsReport {
            /**
                * Connection stats report
                */
            connection: ConnectionStatsReport;
            /**
                * Outgoing stats report
                */
            outbound: Record<string, (OutboundAudioStatsReport | OutboundVideoStatsReport)[]>;
            /**
                * Incoming stats report
                */
            inbound: Record<string, InboundAudioStatsReport | InboundVideoStatsReport>;
            /**
                * Mean opinion score report
                */
            mos: MosReport;
    }
    export { StatsReport, ConnectionStatsReport, InboundAudioStatsReport, InboundVideoStatsReport, OutboundAudioStatsReport, OutboundVideoStatsReport, ReportKind, };
}

declare module 'voximplant-websdk/Hardware' {
    import * as Implement from 'voximplant-websdk/Hardware/src';
    export module Hardware {
            /**
                * Events that are triggered when hardware device is added/removed/updated.
                * @event
                */
            enum HardwareEvents {
                    /**
                        * Triggered when an external device is connected or disconnected or when a default device changes.
                        *
                        * Devices that can trigger the event: microphones, video camera and sound output. Based on browser's
                        * [devicechange](https://caniuse.com/mdn-api_mediadevices_devicechange_event) event.
                        *
                        * @cast EventHandlers.DevicesUpdated
                        */
                    DevicesUpdated,
                    /**
                        * Triggered when a new audio or video renderer added, such as local video or screen sharing.
                        *
                        * @cast EventHandlers.MediaRendererAdded
                        */
                    MediaRendererAdded,
                    /**
                        * Triggered when the local video or audio streaming is updated. E.g., when the local video or screen sharing is stopped.
                        * @cast EventHandlers.MediaRendererUpdated
                        */
                    MediaRendererUpdated,
                    /**
                        * Triggered when the local video or audio streaming is stopped. E.g., when the local video or screen sharing is stopped.
                        * @cast EventHandlers.MediaRendererRemoved
                        */
                    MediaRendererRemoved,
                    /**
                        * Triggered before the local video or audio streaming is stopped. E.g., before local video or screen sharing is stopped.
                        * @cast EventHandlers.BeforeMediaRendererRemoved
                        */
                    BeforeMediaRendererRemoved
            }
            /**
                * Enum that represents video quality.
                */
            enum VideoQuality {
                    /**
                        * Set better video quality for the current web camera.
                        * This option uses the last value from the [CameraManager.testResolutions] function result,
                        * or the data set to the [CameraManager.loadResolutionTestResult].
                        * If there is no result for a target web camera, use 1280x720 resolution
                        */
                    VIDEO_QUALITY_HIGH,
                    /**
                        * Set medium video quality for the current web camera.
                        * This option uses the last value from the [CameraManager.testResolutions] function result,
                        * or the data set to the [CameraManager.loadResolutionTestResult].
                        * If there is no result for a target web camera, use 640x480 resolution
                        */
                    VIDEO_QUALITY_LOW,
                    /**
                        * Set lower video quality for the current web camera.
                        * This option uses the last value from the [CameraManager.testResolutions] function result,
                        * or the data set to the [CameraManager.loadResolutionTestResult].
                        * If there is no result for a target web camera, use 320x240 resolution
                        */
                    VIDEO_QUALITY_MEDIUM,
                    /**
                        * 160x120 resolution
                        */
                    VIDEO_SIZE_QQVGA,
                    /**
                        * 176x144 resolution
                        */
                    VIDEO_SIZE_QCIF,
                    /**
                        * 320x240 resolution
                        */
                    VIDEO_SIZE_QVGA,
                    /**
                        * 352x288 resolution
                        */
                    VIDEO_SIZE_CIF,
                    /**
                        * 640x360 resolution
                        */
                    VIDEO_SIZE_nHD,
                    /**
                        * 640x480 resolution
                        */
                    VIDEO_SIZE_VGA,
                    /**
                        * 800x600 resolution
                        */
                    VIDEO_SIZE_SVGA,
                    /**
                        * 1280x720 resolution
                        */
                    VIDEO_SIZE_HD,
                    /**
                        * 1600x1200 resolution
                        */
                    VIDEO_SIZE_UXGA,
                    /**
                        * 1920x1080 resolution
                        */
                    VIDEO_SIZE_FHD,
                    /**
                        * 3840x2160 resolution
                        */
                    VIDEO_SIZE_UHD
            }
            /**
                * Interface that may be used to manage audio devices, i.e. see current active device, select another active device and get the list of available devices.
                */
            class AudioDeviceManager extends Implement.AudioDeviceManager {
            }
            /**
                * Audio constraints. Audio device is chosen according to these settings.</br>
                * Settings are specified via
                * [AudioDeviceManager.setDefaultAudioSettings]
                *   and
                *   [AudioDeviceManager.setCallAudioSettings].
                */
            interface AudioParams extends Implement.AudioParams {
            }
            /**
                * Interface that may be used to manage cameras on Android device.
                */
            class CameraManager extends Implement.CameraManager {
            }
            /**
                * Camera constraints. Hardware camera is chosen according to these settings.</br>
                * Settings are specified via
                * [CameraManager.setDefaultVideoSettings]
                *   and [CameraManager.setCallVideoSettings].
                */
            interface CameraParams extends Implement.CameraParams {
            }
            /**
                * @hidden
                */
            interface SharingStream extends Implement.SharingStream {
            }
            /**
                * Interface for extended management of local audio/video streams.
                */
            class StreamManager extends Implement.StreamManager {
            }
    }
    export default Hardware;
}

declare module 'voximplant-websdk/PeerConnection/SDP/ParserSDP/Interfaces' {
    /** @hidden
        * Generic representation of attribute
        */
    export interface SdpAttribute {
            /** Attribute name. */
            name: string;
            /** Attribute value or grouped value. */
            value: any;
    }
    /** @hidden
        * This structure declares SDP \a rtpmap attribute.
        */
    export interface SdpRtpmap {
            /** Payload type. */
            pt: string;
            /** Encoding name. */
            encName: string;
            /** Clock rate. */
            clockRate: number;
            /** Parameter. */
            param: string;
    }
    /** @hidden
        * This structure describes SDP \a fmtp attribute.
        */
    export interface SdpFmtp {
            /** Format type. */
            fmt: string;
            /** Format specific parameter. */
            fmtParam: string;
    }
    /** @hidden
        * This structure describes SDP \a rtcp attribute.
        */
    export interface SdpRtcpAttr {
            /** RTCP port number. */
            port: number;
            /** Optional network type. */
            netType?: string;
            /** Optional address type. */
            addrType?: string;
            /** Optional address. */
            addr?: string;
    }
    /** @hidden
        * This structure describes SDP connection info ("c=" line).
        */
    export interface SdpConn {
            /** Network type ("IN"). */
            netType: string;
            /** Address type ("IP4", "IP6"). */
            addrType: string;
            /** The address. */
            addr: string;
    }
    /** @hidden
        * This structure describes SDP bandwidth info ("b=" line).
        */
    export interface SdpBandw {
            /** Bandwidth modifier. */
            modifier: string;
            /** Bandwidth value. */
            value: number;
    }
    /**
        * @hidden
        * This structure describes SDP media descriptor. A SDP media descriptor
        * starts with "m=" line and contains the media attributes and optional
        * connection line.
        */
    export interface SdpMedia {
            /** Media descriptor line ("m=" line)*/
            descr: SdpMediaDescr;
            /** Optional connection info.*/
            conn?: SdpConn;
            /** Number of bandwidth info.*/
            bandwCount?: number;
            /** Bandwidth info. */
            bandw?: SdpBandw[];
            /** Number of attributes.*/
            attrCount?: number;
            /** Attributes.*/
            attr?: SdpAttribute[];
    }
    /** @hidden
        * Media descriptor line ("m=" line)
        */
    export interface SdpMediaDescr {
            /** Media type ("audio", "video")*/
            media: 'audio' | 'video' | string;
            /** Port number.*/
            port: number;
            /** Port count, used only when >2*/
            portCount?: number;
            /** Transport ("RTP/AVP")*/
            transport: string;
            /** Number of formats.*/
            fmtCount: number;
            /** Media formats.*/
            fmt: string[];
    }
    /**
        * @hidden
        * This structure describes SDP session description. A SDP session descriptor
        * contains complete information about a session, and normally is exchanged
        * with remote media peer via a signaling protocol such as SIP.
        */
    export interface SdpSession {
            /** Session origin (o= line)*/
            origin: SdpSessionOrigin;
            /** Subject line (s=)*/
            name: string;
            /** Connection line (c=)*/
            conn: SdpConn;
            /** Number of bandwidth info (b=) */
            bandwCount: number;
            /** Bandwidth info array (b=) */
            bandw: SdpBandw[];
            /** Session time (t= line) */
            time: SdpSessionTime;
            /** Number of attributes.*/
            attrCount: number;
            /** Attributes array.*/
            attr: SdpAttribute[];
            /** Number of media.*/
            mediaCount: number;
            /** Media array.*/
            media: SdpMedia[];
    }
    /** @hidden
        * Session origin (o= line)
        */
    export interface SdpSessionOrigin {
            /** User*/
            user: string;
            /** Session ID*/
            id: string;
            /** Session version*/
            version: string;
            /** Network type ("IN")*/
            netType: string;
            /** Address type ("IP4", "IP6")*/
            addrType: string;
            /** The address.*/
            addr: string;
    }
    /** @hidden
        * Session time (t= line)
        */
    export interface SdpSessionTime {
            /** Start time.*/
            start: number;
            /** Stop time.*/
            stop: number;
    }
}

declare module 'voximplant-websdk/Signaling/MsgEvent' {
    /**
      * IM gen 2
      * @hidden
      */
    export enum MsgEvent {
        onError = "onError",
        onCreateConversation = "onCreateConversation",
        onEditConversation = "onEditConversation",
        onRemoveConversation = "onRemoveConversation",
        onGetConversation = "onGetConversation",
        onGetPublicConversations = "onGetPublicConversations",
        onGetUser = "onGetUser",
        onEditUser = "onEditUser",
        onSetStatus = "onSetStatus",
        onSendMessage = "onSendMessage",
        onEditMessage = "onEditMessage",
        onRemoveMessage = "onRemoveMessage",
        isRead = "isRead",
        onTyping = "onTyping",
        onSubscribe = "onSubscribe",
        onUnsubscribe = "onUnsubscribe",
        onGetSubscriptionList = "onGetSubscriptionList",
        onCreateBot = "onCreateBot",
        onRemoveBot = "onRemoveBot",
        onRetransmitEvents = "onRetransmitEvents"
    }
}

declare module 'voximplant-websdk/Signaling/MsgAction' {
    /**
        * IM gen 2
        * @hidden
        */
    export enum MsgAction {
            /**
                * @hidden
                */
            UNKNOWN = "UNKNOWN",
            createConversation = "createConversation",
            editConversation = "editConversation",
            removeConversation = "removeConversation",
            joinConversation = "joinConversation",
            leaveConversation = "leaveConversation",
            getConversation = "getConversation",
            getConversations = "getConversations",
            getPublicConversations = "getPublicConversations",
            /**
                * @hidden
                */
            searchConversations = "searchConversations",
            /**
                * @hidden
                */
            removeEmptyConversation = "removeEmptyConversation",
            addParticipants = "addParticipants",
            editParticipants = "editParticipants",
            removeParticipants = "removeParticipants",
            getUser = "getUser",
            getUsers = "getUsers",
            editUser = "editUser",
            setStatus = "setStatus",
            sendMessage = "sendMessage",
            editMessage = "editMessage",
            removeMessage = "removeMessage",
            typingMessage = "typingMessage",
            isRead = "isRead",
            subscribe = "subscribe",
            unsubscribe = "unsubscribe",
            manageNotification = "manageNotification",
            getSubscriptionList = "getSubscriptionList",
            /**
                * @hidden
                */
            createBot = "createBot",
            /**
                * @hidden
                */
            removeBot = "removeBot",
            retransmitEvents = "retransmitEvents"
    }
}

declare module 'voximplant-websdk/Hardware/src/AudioDeviceManager' {
    import { Call } from 'voximplant-websdk/Call/Call';
    import { AudioOutputInfo, AudioSourceInfo } from 'voximplant-websdk/Structures';
    import { AudioParams } from 'voximplant-websdk/Hardware/src/AudioParams';
    import { AbstractCall } from 'voximplant-websdk/Call/AbstractCall';
    /**
        * @hidden
        */
    export class AudioDeviceManager {
            /**
                * @hidden
                */
            constructor();
            /**
                * @hidden
                */
            getAudioContext(): any;
            /**
                * Creates an AudioContext object inside SDK. This function should be used on a user gesture at Google Chrome 66 and above
                * See <a href="https://developers.google.com/web/updates/2017/09/autoplay-policy-changes#webaudio"> Google Developers Blog post</a> about this issue
                */
            prepareAudioContext(): void;
            /**
                * Gets the AudioDeviceManager instance
                */
            static get(): AudioDeviceManager;
            /**
                * Returns available audio input devices (sound card/processor). Note that if a new passive microphone is plugged into the same sound card, the method returns that sound card; if a new microphone has its own sound processor, the method returns the updated array with the new device.
                */
            getInputDevices(): Promise<Array<AudioSourceInfo>>;
            /**
                * Returns available audio output devices (sound card/processor). If a new plugged device has its own sound processor, the method returns the updated array with the new device.
                */
            getOutputDevices(): Promise<Array<AudioOutputInfo>>;
            /**
                * Returns default audio settings as the [AudioParams] object.
                */
            getDefaultAudioSettings(): AudioParams;
            /**
                * Sets the default audio settings for calls.
                */
            setDefaultAudioSettings(params: AudioParams): void;
            /**
                * @hidden
                */
            validateIOSCallDevicesParams(call: Call): Promise<AudioSourceInfo[] | undefined>;
            /**
                * Sets audio settings for the specified call.
                */
            setCallAudioSettings(call: Call, params: AudioParams): Promise<void>;
            /**
                * Returns the audio settings of the specified call as a [AudioParams] object.
                */
            getCallAudioSettings(call: Call): AudioParams;
            /**
                * Clears the audio settings of the specified call.
                * @hidden
                */
            clearCallAudioSettings(call: AbstractCall): void;
            /**
                * @hidden
                */
            getCallConstraints(callID: string): Object;
            /**
                * @hidden
                * @return {string}
                * @private
                */
            _traceName(): string;
    }
}

declare module 'voximplant-websdk/Hardware/src/AudioParams' {
    /**
        *
        */
    export interface AudioParams {
            /**
                * Optional. Unique ID of microphone. It can be received via the [AudioDeviceManager.getInputDevices] method.
                */
            inputId?: string;
            /**
                * Optional. Unique ID of a sound card/processor. It can be received via the [AudioDeviceManager.getOutputDevices] method.
                */
            outputId?: string;
            /**
                * Optional. Whether to cancel the participant's echo be cancelled. The default value is true.
                */
            echoCancellation?: boolean;
            /**
                * Optional. If specified, the user agent attempts to obtain media with automatic gain control enabled or disabled as specified.
                */
            autoGainControl?: boolean;
            /**
                * Optional. Whether to supprress the background noise. The default value is true.
                */
            noiseSuppression?: boolean;
            /**
                * Optional. Whether all audio settings should suit each other strictly; the incorrect settings cause an error. If false, the incorrect values are changed to the best appropriate values. The default value is false.
                */
            strict?: boolean;
            /**
                * @hidden
                */
            disableAudio?: boolean;
            /**
                * @hidden
                */
            advanced?: any;
    }
}

declare module 'voximplant-websdk/Hardware/src/CameraManager' {
    import { CameraParams } from 'voximplant-websdk/Hardware/src/CameraParams';
    import { VideoSourceInfo } from 'voximplant-websdk/Structures';
    import { Call } from 'voximplant-websdk/Call/Call';
    /**
        * @hidden
        */
    export class CameraManager {
            /**
                * @hidden
                */
            constructor();
            /**
                * Get the CameraManager instance
                */
            static get(): CameraManager;
            /**
                * Set default video settings for calls.
                */
            setDefaultVideoSettings(params: CameraParams): Promise<void>;
            /**
                * Return default video settings as the [CameraParams] object.
                */
            getDefaultVideoSettings(): CameraParams;
            /**
                * Set video settings for the specified call.
                */
            setCallVideoSettings(call: Call, params: CameraParams): Promise<void>;
            /**
                * Return video settings of the specified call as the [CameraParams] object.
                */
            getCallVideoSettings(call: Call): CameraParams;
            /**
                * @hidden
                */
            getCallConstraints(callID: string): Object;
            /**
                * Return available video input devices (web camera(s)).
                */
            getInputDevices(): Promise<Array<VideoSourceInfo>>;
            /**
                * @hidden
                */
            static legacyParamConverter(videoParams: any): CameraParams;
            /**
                * Start camera resolution test for each video source in system.</br>
                * *Attention!* This procedure may take a lot of time and send multiple Camera requests for
                * the Mozilla Firefox and Apple Safari browsers!</br>
                * Please, do not run it without warning user's request and attention.</br>
                * After running this function, please, save result to a browser storage (like LocalStorage or IndexedDB) and use it
                * in future with the [loadResolutionTestResult] function to restore
                * results.
                * This function is mandatory only if you use Hardware.VideoQuality.VIDEO_QUALITY_HIGH,Hardware.VideoQuality.VIDEO_QUALITY_MEDIUM or
                * Hardware.VideoQuality.VIDEO_QUALITY_LOW enums as video settings and strongly not recommended to use in another case.
                * @returns {Promise<any>}
                */
            testResolutions(cameraId?: string): Promise<any>;
            /**
                * Restoring a camera resolution test result previously got by [testResolutions]
                * function.
                * @returns {Promise<void>}
                */
            loadResolutionTestResult(data: any): boolean;
            /**
                * @hidden
                * @return {string}
                * @private
                */
            _traceName(): string;
    }
}

declare module 'voximplant-websdk/Hardware/src/CameraParams' {
    import Hardware from 'voximplant-websdk/Hardware';
    /**
        * @hidden
        */
    export interface CameraParams {
            /**
                * Unique ID of camera. It can be received via the [CameraManager.getInputDevices] method.
                */
            cameraId?: string;
            /**
                * Optional. One of the <a href="/docs/references/websdk/voximplant/hardware/videoquality">video quality</a> values. The parameter is prior than <a href="#framewidth">frameWidth</a> and <a href="#frameheight">frameHeight</a> parameters.
                */
            videoQuality?: Hardware.VideoQuality;
            /**
                * Optional. Whether to use the front camera on a mobile device.
                *
                * This parameter is available only for mobile devices. We do not recommend using this parameter for desktop devices. The default value for mobile devices is **true**.
                */
            facingMode?: boolean;
            /**
                * Optional. Frame width in pixels. The parameter is less prior than <a href="#videoquality">videoQuality</a>.
                */
            frameWidth?: number;
            /**
                * Optional. Frame height in pixels. The parameter is less prior than <a href="#videoquality">videoQuality</a>.
                */
            frameHeight?: number;
            /**
                * Optional. Whether all video settings should suit each other strictly; the incorrect settings cause an error. if false, the incorrect values are changed to the best appropriate values. The default value is false.
                */
            strict?: boolean;
            /**
                * Optional. Frames per second.
                */
            frameRate?: number;
            /**
                * Optional. Aspect ratio.
                */
            aspectRatio?: number;
    }
}

declare module 'voximplant-websdk/Hardware/src/SharingStream' {
    import { MediaRenderer } from 'voximplant-websdk/Media/MediaRenderer';
    /**
      * @hidden
      */
    export interface SharingStream {
        renderer?: MediaRenderer;
        stream: MediaStream;
    }
}

declare module 'voximplant-websdk/Hardware/src/StreamManager' {
    import Hardware from 'voximplant-websdk/Hardware';
    import { EventListenerOption, EventTarget } from 'voximplant-websdk/EventTarget';
    import { Call } from 'voximplant-websdk/Call/Call';
    import { MediaRenderer } from 'voximplant-websdk/Media/MediaRenderer';
    import { SharingStream } from 'voximplant-websdk/Hardware/src/SharingStream';
    import { TrackType } from 'voximplant-websdk/Types';
    /**
        * @hidden
        */
    export class StreamManager extends EventTarget<Hardware.HardwareEvents> {
            isLocalVideoRequested: boolean;
            /**
                * @hidden
                */
            constructor();
            /**
                * Gets the StreamManager instance
                */
            static get(): StreamManager;
            /**
                * @hidden
                * @param {Call} call
                * @returns {Promise<MediaStream>}
                */
            getCallStream(call: Call, options?: {
                    force?: boolean;
                    resetDefaultAudio?: boolean;
            }): Promise<MediaStream>;
            /**
                * @hidden
                * @param {Call} call
                * @returns {Promise<MediaStream>}
                * @private
                */
            _updateCallStream(call: Call): Promise<MediaStream>;
            /**
                * @hidden
                * @param {Call} call
                * @returns {Promise<EventHandlers.Updated>}
                */
            updateCallStream(call: Call): Promise<void>;
            updateStreamSettings(call: Call): Promise<void>;
            /**
                * @hidden
                * @param {Call} call
                */
            remCallStream(call: Call): void;
            /**
                * @hidden
                * @param {MediaStream} stream
                */
            _remCallStream(stream: MediaStream): void;
            /**
                * @hidden
                */
            clear(): void;
            /**
                * Lists the currently used containers for local audio and video streams.
                */
            getLocalMediaRenderers(): MediaRenderer[];
            /**
                * Turns on the local video. The container for the local video elements should be specified in the
                * [Config.localVideoContainerId] field in the [Client.init] config.
                * If not specified, local videos are appended to end of the *<body>* element.
                * Use the <a href="#hidelocalvideo">hideLocalVideo</a> method to turn off local video.
                */
            showLocalVideo(placeOnDom?: boolean): Promise<MediaRenderer>;
            /**
                * @hidden
                */
            updateLocalVideo(rendererKind?: MediaRenderer['kind']): Promise<void>;
            /**
                * Turns off the local video. Use the <a href="#showlocalvideo">showLocalVideo</a> method to turn on the local video.
                */
            hideLocalVideo(): Promise<void>;
            /**
                * Register a handler for the specified event. The method is a shorter equivalent for *addEventListener*. One event can have more than one handler; handlers are executed in order of registration.
                * Use the [StreamManager.off] method to delete a handler.
                */
            on(event: Hardware.HardwareEvents, handler: (ev: any) => void, options?: EventListenerOption): void;
            /**
                * Remove a handler for the specified event. The method is a shorter equivalent for *removeEventListener*. If a number of events has the same function as a handler, the method can be called multiple times with the same handler argument.
                */
            off(event: Hardware.HardwareEvents, handler?: (ev: any) => void): void;
            /**
                * Get sharing media and create renderer if need.
                * @hidden
                * @param {Call} call
                * @returns {Promise<Hardware.SharingStream>}
                */
            _newScreenSharing(call: Call): Promise<SharingStream>;
            /**
                * @hidden
                * @param {Call} call
                * @returns {Hardware.SharingStream[]}
                * @private
                */
            _getScreenSharing(call: Call): SharingStream[];
            /**
                * @hidden
                * @param {Call} call
                * @param {SharingStream} sharingStream
                * @returns {Promise<void>}
                * @private
                */
            _clearScreenSharing(call: Call, sharingStream: SharingStream): Promise<void>;
            /**
                * @hidden
                * @param {Call} call
                * @returns {{[p: string]: TrackType}}
                * @private
                */
            _getTracksKind(call: Call): {
                    [id: string]: TrackType;
            };
            /**
                * @hidden
                * @return {string}
                * @private
                */
            _traceName(): string;
            /**
                * @hidden
                */
            static getUserMedia(constraints: MediaStreamConstraints): Promise<MediaStream>;
            /**
                * @hidden
                */
            static clearUmCache(): Promise<void>;
    }
}

declare module 'voximplant-websdk/PeerConnection/ReInviteQ' {
    /**
        * @hidden
        */
    import { Call } from 'voximplant-websdk/Call/Call';
    /**
        * @hidden
        */
    export class ReInviteQ {
            constructor(call: Call, _pcStatus: {
                    (): boolean;
            });
            runNext(): void;
            add(member: ReIviteQMember): void;
            clear(): void;
            /**
                * @hidden
                * @return {string}
                * @private
                */
            _traceName(): string;
    }
    /**
        * @hidden
        */
    export interface ReIviteQMember {
            resolve: Function;
            reject: Function;
            fx: Function;
    }
}

declare module 'voximplant-websdk/typings/peerConnection' {
    /**
        * @hidden
        */
    export type LineIndex = number;
    /**
        * @hidden
        * @description i.e. a=candidate:3824035120 1 udp 2112260223 192.168.1.2 53511 typ host generation 0 network-id 1 network-cost 10
        */
    export type CandidateString = string;
}

